# 代码大全

### 第1 章 欢迎进入软件构建的世界

### 第2 章 用隐喻来更充分地理解软件开发　　9

### 第 3 章 三思而后行：前期准备　　23

### 第4章 关键的“构建”决策　　61

### 第5章 软件构建中的设计　　73

### 第 6 章 可以工作的类　　125

### 第 7 章 高质量的子程序　　161

### 第 8 章 防御式编程　　187

### 第 9 章 伪代码编程过程　　215

### 第10章 使用变量的一般事项237

### 第 11 章 变量名的力量　　259

### 第 12 章 基本数据类型　　291

### 第13章 不常见的数据类型　319

### 第14章 组织直线型代码　　347

### 第 15 章 使用条件语句　　355

### 第 16 章 控制循环　　367

### 第17章 不常见的控制结构　391

### 第 18 章 表驱动法　　411

### 第 19 章 一般控制问题　　431

### 第 20 章 软件质量概述　　463

### 第 21 章 协同构建　　479

### 第 22 章 开发者测试　　499

### 第 23 章 调试　　535

### 第 24 章 重构　　563

### 第 25 章 代码调整策略　　587

### 第 26 章 代码调整技术　　609

### 第27章 程序规模对构建的影响649

### 第 28 章 管理构建　　661

### 第 29 章 集成　　689

### 第 30 章 编程工具　　709

### 第 31 章 布局与风格　　729

### 第 32 章 自说明代码　　777

### 第 33 章 个人性格　　819

### 第 34 章 软件工艺的话题

### 第 35 章 何处有更多信息





# 重构

在项目的初期，复杂度和代码腐化程度还未达到峰值的时候，一开始开发进展会很快，这会给公司领导层一种错觉，觉得真正的开发速度就应该这样，应该一直会保持下去。但是当发展到一定阶段后，想要添加一个新功能时，需要的时间会比之前的时间要长很多，开发人员需要花更多的时间去思考，去考虑如何把新功能塞进现有的代码库中，避免因改一个地方而出现牵一发而动全身的尴尬境界。整个项目的代码库看起来就像是在补丁上再补上补丁，需要像考古一样才能弄明白整个系统是如何工作的，这些负担不断地拖慢新增功能的速度，到最后程序员实在忍无可忍时就会提出“要不，我们重新做一个新版本放弃现在这个项目吧？”。

那么，到底一个项目代码腐化到什么地步，我们应该开始重构呢？在前辈马丁.福勒大神的《重构》一书中，早已经总结出了实用的重构的24个契机，让我们一一来细数对照一下，看看自己在编写代码时，是否有犯过这些错误。



![img](https://user-gold-cdn.xitu.io/2019/8/28/16cd8bb905f9f806?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



## 何时重构

#### 1. 神秘的命名

一个好的命名，能让读者一眼就清楚代码的意思，整洁代码中最重要的一环是从好的命名开始。现实中很多人不愿意给程序改名，觉得不值得花费这个时间，但好的名字能节省未来用在猜谜上的大把时间，所以当项目中出现神秘命名时，便是重构的开始。关于代码有意义的命名请参阅《代码整洁之道》第二章 有意义的命名。

#### 2. 重复代码

在优秀的开发者心中，践行着事不过三的原则，即一段代码在三处以上的地方用到时，便是开始重构的时候，三不是一个绝对值，准确的说，如果你在一个以上的地方看到相同的代码结构，便应该立即开始重构代码。很多新手开发者在写代码时，喜欢通过拷贝粘贴的方式进行开发，这会给后期其他人维护和修改代码造成更多的不必要的麻烦。

#### 3. 过长函数

有大佬曾讲过，但凡是一个函数如果超过50行以上的代码，就应该开始考虑进行重构它。根据我以往的开发经验，粒度越小的函数，会活的最长最好，他们都遵循着单一职能原则。当函数过长，复杂度就会越高，理解就越难，所以很多开发者喜欢在长长的函数中，加入更多的注释来解释程序，这是一个错误的做法，过多的注释内容更容易干扰代码的阅读和理解。所以当我们感觉需要用注释来说明代码逻辑的时候，我们就应该把需要注释的内容单独抽象出来，写到一个单独的函数中去，并命一个直观的好名字。

#### 4. 过长参数列表

曾经我在编写Angular1的代码时，在控制器中经常需要注入很多依赖对象，在回调函数中需要传递大量的参数，导致经常自己手抖或者顺序不对导致一些BUG。过长的参数列表会经常令人产生迷惑，容易让人犯错，我们可以把多个参数合并成一个对象，通过传递对象的方式减少过长的参数列表，从而让代码更简洁已读。

#### 5. 全局数据

在项目中使用全局数据，容易造成数据的污染与冲突。在很多的代码规范中，对全局数据的使用都是明令禁止的，全局数据从代码库任何一个位置都可以修改它，这使其排查BUG的时候异常的困难。在实际开发中可以对全局数据进行抽象封装，在使用到数据的地方进行手动导入操作。

#### 6. 可变数据

对于弱类型开发语言Js，可变数据的问题很容易就发生，在一处更新数据后，却没有意识到软件的另一处期望着完全不同数据类型的数据，于是就改出了一处BUG，这种情况发生在很罕见的情况下，所以要找出故障的原因也会更加的困难，所以现在Ts开始在前端技术圈愈发流行起来。

#### 7. 发散式变化

在软件开发之初，我们希望软件能够更容易被修改，一旦需要修改，我们就能立即跳转到系统的某一点，只在该位置做修改即可完成。如果某个模块经常因为不同的原因在不同的方向上发生变化，发散式变化就出现了。

#### 8. 分散修改

分散的修改类似于发散式变化，正好又相反。如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改，那么所面临的问题就是分散的修改，在这种情况下，你的代码散步在多个地方，你不但很难找到它们，也很容易错过某个重要的修改。这时候你需要进行封装和抽象，或者搬移某些代码到同一个模块中，以达到集中修改的地步。

#### 9. 依恋情结

接受过面向对象编程的开发者在编写代码时，或多或少都会想到代码要高内聚、低耦合、开放封闭等。但有时你会发现，一个函数跟另一个模块中的函数或者数据交流格外频繁，远胜于在自己所处模块内部的访问，这就是代码的依恋情结。我们可以通过搬移这部分代码到所访问模块的内部，或者我们再抽象一层，将函数分解为多个较小的函数，分别放置在不同地点。

#### 10. 数据泥团

曾经在维护他人代码时，经常看到在很多地方相同的字符串、相同的参数散落在代码的各个角落里，使其让人很难维护这样的代码。我们只需要将这些散落在到处的数据，进行抽象，将它们提炼到一个独立的对象中，再通过导入对象的方式访问这些数据即可，这样就可以帮我们降低很多重复的内容，使其修改代码时也不会再出现分散的修改。

#### 11. 基本类型偏执

在一些代码腐化的项目中，基本类型偏执是很常见的问题，比如价格可以用浮点数类型进行表示，坐标范围可以封装为对象进行展示，实际却是用字符串进行存储和展示。字符串似乎成了万能的数据类型，完全可以将这些类型偏执的代码替换为正确的类型进行展示。

#### 12. 重复的switch

在新手编写的代码中，当遇到条件判断或者分支判断时，大量重复嵌套的if和重复的switch是常见的处理问题的方法。这些重复的switch的问题在于，当你想增加一个选择分支时，就必须找到所有的switch，一一进行修改。对于重复的分支判断，我们可以利用`多态`来取代条件表达式，这样会让代码更优雅。

#### 13. 循环语句

在大量的业务场景中，循环语句都是不必要的，很多新人喜欢写大量的for循环语句，来实现需求。实际上我们可以利用`管道`来取代循环，比如使用filter、map、forEach等方法，帮助我们更快地看清被处理的元素以及处理他们的动作。

#### 14. 冗余的元素

在项目开发中，为了支持变化促进代码复用，往往我们会进行代码的抽象与封装，但往往这时候很难掌握抽象的度，导致过渡封装。可能一个方法名字和实现代码看起来一模一样，可能一个抽象出来的类根本就是一个简单的函数等，这就造成了代码的冗余。我们可以通过合并的方式，将过度抽象的代码给释放出来，从而减少代码的冗余。

#### 15. 夸夸其谈通用性

同样，过度设计的代码中，必定会出现各种各样的特殊情况，用来处理一些特别罕见或非必要的一些事情，实际上这些特殊的情况只会让系统更难维护和理解，所以在设计之初就考虑清楚如果确实能用上那么这么做是值得的，如果用不到，就只会让代码更加容易出现坏味道。

#### 16. 临时字段

在多人编写的项目中，也许你有看到过他人，在代码中定义某个临时字段，但这个字段只在特定的情况下才会使用到，如果代码没进入分支，这样的临时字段就很容易让人产生误解。我们可以将这些临时的字段，抽象到一个专门的类当中，然后把这些字段和相关的代码都搬移到这个类中，再在需要的地方调用该类中的方法即可。

#### 17. 过长的消息链

在使用他人编写的代码获取数据时，我们查看其逻辑时，发现你访问的对象，是代理的另外一个对象，另外一个对象又再请求另一个对象时，这时过长的消息链就出现了，如果你着急修复一个BUG，遇上这样的代码也许会让你抓狂。当消息链过长时，我们可以通过抽象和搬移这些代码到一个类中，来截断过长的消息联来缩短代码的深度，使其代码的可读性大大提高。

#### 18. 中间人

面向对象编程的特征之一就是封装，封装往往会伴随着委托。但也许你看到过某个类的接口有一半的函数都委托给其他的类进行实现的话，这就是过度运用封装了。这时候我们应该移除中间人代码，直接和真正的实现对象进行交互。

#### 19. 内幕交易

在实际开发中，很多人都贯彻着模块的高内聚，但内聚后势必就会增加模块间大量的交换数据，这会增加模块间的耦合。如果两个模块间一直存在着私下的交换数据，那么我们就有必要找出两个模块间共同数据，抽象为两者的数据中介，把这种交换行为放在明面上。

#### 20. 过大的类

臃肿的代码中，最大的功臣莫过于一个超大的类。一个类需要做很多的事情，自然就会出现很多的字段，重复代码也就接踵而至，代码开始混乱并最终走向死亡。对于这种大类，我们需要运用抽象能力，对这些代码进行提炼，相同的业务提炼到相应的类中，公共的内容提取到超类中。

#### 21. 异曲同工的类

在迭代过多个版本的代码中，异曲同工的类格外的多，大体上看大家似乎都做着一样的事情，仅有一些细微的差别，比如一些参数的不同等。这些类充斥着大量重复的代码，我们可以通过改变函数的声明将函数的参数变得一致，再将几者进行合并，如果出现重复代码，我们再将他们抽象为超类进行补偿。

#### 22. 纯数据类

在一些有经验的程序员中，他们出于方便管理的考虑，会把一些零散的数据，放到一个专门的纯数据类中，这样这个类就拥有一大堆的字段，以及用于访问这些字段的函数。但这些纯数据类，除了用于访问读写这些字段外，就一无是处，我们应该把处理数据的行为，从其他地方搬移到纯数据类中。

#### 23. 被拒绝的遗赠

在维护一些有继承关系的代码时，经常发现，一个子类继承了父类，获得了父类的所有的函数和数据，但子类却只从父类哪里取得一个值，父类其他的函数和值就被子类给拒绝了。这意味着继承体系设计的错误，我们需要为这个子类新建一个兄弟类，再把用不到的函数和值推给那个兄弟类，这样父类就持有所有子类共享的东西了。

#### 24. 注释

优秀的代码，自带解释性。但实际上大部分注释的存在都是因为代码很糟糕，所以不得不加一些注释内容，便于进行补充说明。所以，当你感觉需要写注释时，就需要先尝试进行代码重构，运用提炼函数和改变函数声明的手法，试着让所有的注释都变得很多余。













# 重构代码的7个阶段

##### 

你曾去想重构一个很老的模块，但是你只看了一眼你就恶心极了。文档，奇怪的函数和类的命名，等等，整个模块就像一个带着脚镣的衣衫褴褛的人，虽然能走，但是其已经让人感到很不舒服。面对这种情况，真正的程序员会是不会认输的，他们会接受挑战认真分析，那怕重写也在所不惜。最终那个模块会被他们重构，就像以前和大家介绍过的[那些令人销魂的编程方式](https://coolshell.cn/articles/2058.html)中的屠宰式编程一样。下面是重构代码的几个阶段，文章来自：[The 7 stages of refactoring](http://norsedev.blogspot.com/2011/08/n-stages-of-refactoring.html)，下面的翻译只是意译。

**第一阶段 – 绝望**

在你开始去查看你想要重构的模块的，你会觉得好像很简单，这里需要改一个类，那里需要改两到三个函数，重写几个函数，看上去没什么大不了的，一两天就搞定了。于是你着手开始重构，然后当你调整重构了一些代码，比如改了一些命名，修理了一些逻辑，渐渐地，你会发现这个怪物原来体型这么大，你会看到与代码不符甚至含糊不清的注释，完全摸不着头脑的数据结构，还有一些看似不需要方法被调了几次，你还会发现无法搞清一个函数调用链上的逻辑。你感到这个事可能一周都搞不定，你开始绝望了。

**第二阶段 – 找最简单的做**

你承认你要重构的这个模块就是一个可怕的怪物，不是一两下就可以搞定的，于是你开始着干一些简单的事，比如重新命名一下几个函数，移除一些代码的阻碍，产生几个常量来消除magic number，等等，你知道这样做至少不会让代码变得更糟糕。

**第三阶段 – 再次绝望**

但是接下来的事会让你再次撞墙。你会发现那些代码的瑕疵是些不痛不痒的事，改正这些事完全于事无补，你应该要做的事就是重写所有的东西。但是你却没有时间这么干，而这些代码剪不乱理还乱，耦合得太多，让你再一次绝望。所以，你只能部分重写那些不会花太多时间的部分，这样至少可以让这些老的代码能被更多的重用。虽然不完美，但是至少可以试试。

**第四阶段 – 开始乐观**

在你试着部分重构这个模块几天之后，随着重构了几个单元后，虽然你发现改善代码的进度太慢了，但此时，你已知道代码应该要被改成什么样，你在痛苦之后也锁定了那些那修改的类。是的，虽然你的时间预算已经超支，虽然要干的事比较多，但你还是充满希望，觉得那是值得的。你胸中的那团火又被点燃了。

**第五阶段  – 快速了结**

在这个时候，你发现你已花了太多的时间，而情况越来越复杂，你感到你所面对的情况越来越让你越到不安，你明白你自己已经陷入了困境。你原本以为只需要一次简单的重构，然而现在你要面对的是重写所有的东西。你开始意识到原因是因为你是一个完美主义者，你想让代码变得完美。于是你开始在怠慢你文档，并想找到一个捷径来重写老的代码，你开始采用一些简单而粗暴，快速而有点肮脏的方法。虽然不是很完美，但你就是这样去做了。然后，你开始运行测试做UT，发现UT报告上全是红色，几乎全都失败了，你恐慌了，于是快速地fix代码，然后让UT 能工作。此时，你拍拍自己胸口，说到，没问题 ，于是就把代码提交了。

**第六阶段 – 修改大量的Bug**

你的重写并不完美，虽然其过了测试，但是那些UT测试对于你的新的代码有点不太合适，虽然他们都没有报错，但是他们测试得范围太小了，没有覆盖到所有的情况和边界。所以，在这以后，你还需要几周或是更长的时间不得不来修正越来越多的bug，这使得你的设计和代码在每一次quick-fix后就变得越来越难看。此时，代码已经不像你所期望的那样完美了，但你依然觉得他还是比一开始要好一些。这个阶段可能历经几个月。

**第七阶段  – 觉悟**

经过了6个月，你重写的模块又出了一个比较严重的bug。这让你重构的那个模块变得更难堪。你发现出的这个问题是和当初的设计不一致，你还发现被你重构掉的那段老的代码并不是当初看上去的那么坏，那段老的代码确实考虑到了一些你未曾考虑到的事情。这个时候，你团队里有人站出来说这个模块应该被重构或是重写，而你却不动声色地一言不发，并希望那个站出来的人能在几个月后能觉悟起来。

——————

![代码重构](http://ww2.sinaimg.cn/large/538efefbjw1dt8f6ua5rpg.gif)

不知道这是不是你的经历，我经历过很多次这样的事。对于很多维护性质的项目，我犯过的错误让我成了一个实实在在的保守派，我几乎不敢动，那怕看到代码很不合口味。当然，那些从来没有写过代码的敏捷咨询师一定会说用TDD或是UT可以让你的重构更有效也更容易，因为这样会让他们显得更我价值，但我想告诉你，这种脱离实际的说法很不负责任，这就好比说—— **我在杀猪的时候遇到了一些麻烦，因为我对猪的生理结构不清楚，或是这本来就是一头畸形的猪，导致我杀的猪很难看，而伟大的敏捷咨询师却告诉我，要用一把更快更漂亮的刀**。软件开发永远不是那么简单的事，杀猪也一样。



# 何谓重构？

两个定义：

1. **名词形式**
   重构 (名词)**：**对软件内部的一种太纵横，目的是在不改变软件可观察的前提下，提高其可理解性，降低其修改成本。
2. **动词形式**
   重构 (动词)**：**使用一系列的重构手法，在不改变软件可观察的行为的前提下，调整其结构。

上面是重构的学术解释，相信一些大神是可以直接一步到位的领略它的意思。我比较喜欢通俗易懂的解释：
你要问我 “重构就只是整理代码吗？” 在某种角度来说 还真是。 but ! 重构肯定有其独到的地方：
**它还提供一种 更高效 且 受控的 代码整理技术。**

划重点哈！

作者还对重构进行了另外两方面的扩展。让我一起来看下还有什么好玩的：

1. **重构的目的是是软件更容易被理解和修改**。

   ```
   也就是说让你的修改但你只能对软件的可观察的外部行为造成很小的变化甚至不造成变化。
      和重构形成对比的是 **性能优化** (我反正一开始觉得这两个都是一样的)，
      差就差在性能优化通常不会改变组件的行为（除了执行速度）指挥改变其内部结构。
      但是！   
      这两个的出发点不同： **性能优化往往是代码较难理解，但是为了得到所需的性能你不得不这么做。**
   ```

2. **重构不会改变软件的可观察的行为**

   ```
   也就是说重构之后软件的功能一如以往。所有人除了你自己都不知道有东西改变过（就像鬼子进村悄悄的进行，打枪的不要）。
   ```



## **2. 为何重构？**

重构有四大好处：

1. **重构改进软件设计**
   如果没有重构，程序的设计会逐渐腐败变质。重构很像是在整理代码，你所做的就是让所有东西回到应出的位置上。经常性的重构可以帮助维持自己该有的形态。
2. **重构使软件更容易理解**
   重构可以帮助我们让代码更易读。
3. **重构帮助找到 bug**
   对代码进行重构，可以帮助我们深入理解代码，对代码理解的越深，就越能帮我们找到 bug。重构能够帮大家更有效地写出强健的代码。（这对程序员来说是重点）
4. **重构提高编程速度**
   重构可以帮助我们更快速地开发软件，因为它阻止系统腐败变质，它甚至还可以提高设计质量。（这对 Boss 来说是重点）



```
Any fool can write code that a computer can understand. Good programmers write code that humans can understand.
```

任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的代码。



## **3. 何时重构？**



重构 **不是** 一件应该特别拨出时间做的事情，重构应该随时随地进行。**不应该为重构而重构，之所以重构**，是因为我们想做别的什么事，而重构可以帮助我们把那些事做好。



作者给出了一个三次原则，让我们来看一下：



**三次法则：事不过三，三则重构。**



1. **添加功能**时重构。
2. **修补错误**时重构。
3. **复审代码**时重构。



够明确了吧！ 当你发现你的代码正符合里面的条件式那就抓紧时间重构吧。



## **4. 怎么对经理说？**



**此章节只可意会不可言传。**



## **5. 重构的难题**



当你使用一种可以提高生成力的新技能时，一定要**仔细思考此场景是不是适用**。 别人的 “好媳妇” 在你着没准就没那么好用。



假如你发现你确实需要重构，请参考仔细阅读下面你可能会遇到的难题：



1. **数据库难在哪？**

   ```
   1.绝大多数的程序都和背后的数据库结构紧密的耦合在一起。
      2.数据迁移
   ```

2. **接口修改难在哪？**

   ```
   1.已经发布了的接口
   ```

3. **何时不该重构？**

   ```
   1.代码根本无法工作或者太糟糕，重构还不如重写来的简单。
   
      2.在项目的最后期限，应该避免重构
   ```





**中场休息**
文章至此，大家应该知道自己现在所处的阶段适不适合重构心里有点 b 数了吧？
不适合就别往下看了，光知道重构是什么东西就可以，以后用到再回来看看这篇文章。



下面的文章能告诉你怎么重构，只是框架，我又不可能把书都抄下来，如果大家真的需要重构不如立刻行动买书看，或者下载我的电子书。（免费的哦~）





## **6. 代码的坏味道**



1. **重复代码** (Duplicated Code)
2. **过长函数** (Long Method)
3. **过大的类** (Large Class)
4. **过长参数列** (Long Parameter List)
5. **发散式变化** (Divergent Change)：一个类受多种变化的影响
6. **霰弹式修改** (Shotgun Surgery)：一种变化引发多个类相应修改
7. **依恋情结** (Feature Envy)：函数对某个类的兴趣高过自己所处类的兴趣
8. **数据泥团** (Data Clumps)：相同的若干项数据出现在不同地方，这些绑在一起出现的数据应该有属于它们自己的对象
9. **基本类型偏执** (Private Obsession)：很多人不愿意在小任务上运用小对象
10. **switch 惊悚现身** (Switch Statements)：switch 语句会在很多地方重复出现，一改则需全改
11. **平行继承体系** (Parallel Inheritance Hierarchies)：当你为某一个类增加子类时，也必须为另一个类相应增加一个类
12. **冗赘类** (Lazy Class)：如果一个类不值得存在，那就让它消失
13. **夸夸其谈的未来星 (**Speculative Generality)：预留的无用的抽象类，无用的抽象参数
14. **令人迷惑的暂时字段** (Temporary Field)：类中某个字段只为某些特殊情况而设置
15. **过度耦合的消息链** (Message Chains)：用户向一个对象请求另一个对象，然后再向后者请求另一个对象......
16. **中间人** (Middle Man)：无用的委托，过多的中间层
17. **狎昵关系** (Inappropriate Intimacy)：两个类过于亲密，一个类过于关注另一个类的成员
18. **异曲同工的类** (Alternative Classes with DifferentInterfaces)：不同名字的类或函数，作者相同的事
19. **不完美的库类** (Incomplete Library Class)：类库设计不可能完美
20. **纯数据类** (Data Class)：一个类拥有一些字段以及用于访问这些字段的函数，除此之外一无长物
21. **被拒绝的遗赠** (Refused Bequest)：子类不想继承超类所有的函数和数据，只想挑几样来玩
22. **过多的注释** (Comments)



## **7. 构筑测试体系**



1. 重构的首要前提是拥有一个**可靠的测试环境**。
2. **只要写好一点功能，就立即添加测试**，并确保所有测试都完全自动化，让它们检查自己的测试结果。一套测试就是一个强大的 bug 侦测器，能够大大缩减查找 bug 所需要的时间。
3. **撰写测试代码的最有用时机是在开始编程之前。**当你需要添加特性的时候，先写相应测试代码。
4. **多运用单元测试。**测试你最担心出错的地方，考虑可能出错的边界条件。不要因为测试无法捕捉所有 bug 就不写测试，因为测试的确可以捕捉到大多数 bug。“花合理时间抓出大多数 bug” 要好过 “穷尽一生抓出所有 bug”。



## **8. 重新组织函数**



1. **提炼函数**（Extract Method）。你有一段代码可以被组织在一起并独立出来。将这段代码放进一个独立函数中，并将函数名称解释该函数的用途。
2. **内联函数**（Inline Method）。一个函数的本体与名称同样清楚易懂。在函数调用点插入函数本体，然后移除该函数。
3. **内联临时变量**（InlineTemp）。你有一个临时变量，只被一个简单表达式赋值一次，而它妨碍了其他重构手法。将所有对该变量的引用动作，替换为对它赋值的那个表达式自身。
4. **以查询取代临时变量**（Replace Temp withQuery）。你的程序以一个临时变量保存某一表达式的运算结果。将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可被其他函数使用。
5. **引入解释性变量**（Introduce ExplainingVariable）。你有一个复杂的表达式。将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。
6. **分解临时变量**（Split TemporaryVariable）。你的程序有某个临时变量被赋值过一次，它既不是循环变量，也不被用于收集计算结果。针对每次赋值，创造一个独立、对应的临时变量。
7. **移除对参数的赋值**（Remove Assignments Parameters）。代码对一个参数进行赋值。以一个临时变量取代参数的位置。
8. **以函数对象取代函数**（Replace Method with MethodObject）。你有一个大型函数，其中对局部变量的使用使你无法采用 ExtractMethod。将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段。然后你可以在同一个对象中将这个大型函数分解为多个小型函数。
9. **替换算法**（Substitute Algorithm）。你想要把某个算法替换为另一个更清晰的算法。将函数本体替换为另一个算法。



## **9. 在对象之间搬移特性**



1. **搬移函数**（MoveMethod）。你的程序中，有个函数与其所驻之外的另一个类进行更多交流：调用后者，或被后者调用。在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是将旧函数完全移除。
2. **搬移字段**（MoveField）。你的程序中，某个字段被其所驻类之外的另一个类更多地用到。在目标类新建一个字段，修改源字段的所有用户，令它们改用新字段。
3. **提炼类**（Extract Class）。某个类做了应该有两个类做的事。建立一个新类，将相关的字段和函数从旧类搬移到新类。
4. **将类内联化**（Inline Class）。某个类没有做太多事情。将这个类的所有特性搬移到另一个类中，然后移除原类。
5. **隐藏 “委托关系”**（Hide Delegate）。客户通过一个委托来调用另一个对象。在服务类上建立客户所需的所有函数，用以隐藏委托关系。
6. **移除中间人**（Remove Middle Man）。某个类做了过多的简单委托动作。让客户直接调用受托类。
7. **引入外加函数**（Introduce ForeignMethod）。你需要为提供服务的类增加一个函数，但你无法修改这个类。在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。
8. **引入本地扩展**（Introduce LocalExtension）。你需要为服务类提供一些额外函数，但你无法修改这个类。建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或包装类。



## **10. 重新组织数据**



1. **自封装字段**（Self Encapsulate Field）。你直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙。为这个字段建立取值 / 设值函数，并且只以这些函数来访问字段。
2. **以对象取代数据值**（Replace Data Value withObject）。你有一个数据项，需要与其他数据和行为一起使用才有意义。将数据项变成对象。
3. **将值对象改为引用对象**（Change Value toReference）。你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象。将这个值对象变成引用对象。
4. **将引用对象改为值对象**（Change Reference to Value）。你有一个引用对象，很小且不可变，而且不易管理。将它变成一个值对象。
5. **以对象取代数据**（Replace Array withObject）。你有一个数组，其中的元素各自代表不同的东西。以对象替换数组，对于数组中的每个元素，以一个字段来表示。
6. **复制 “被监视数据”**（Duplicate ObservedData）。你有一些领域数据置身 GUI 控件中，而领域函数需要访问这些数据。将该数据复制到一个领域对象中。建立一个 Observe 模式，用以同步领域对象和 GUI 对象内的重复数据。
7. **将单向关联改为双向关联**（Change Unidirectional Association toBidirectional）。两个类都需要使用对方特性，但其间只有一条单向链接。添加一个反向指针，并使修改函数能够同时更新两条链接。
8. **将双向关联改为单向关联**（Change Bidirectional Association toUnidirectional）。两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性。去除不必要的关联。
9. **以字面常量取代魔法数**（Replace Magic Number with SymbolicConstant）。你有一个字面数值，带有特别含义。创造一个常量，根据其意义为它命名，并将上述的字面数值替换为这个常量。
10. **封装字段**（Encapsulate Field）。你的类中存在一个 public 字段。将它声明为 private，并提供相应的访问函数。
11. **封装集合**（EncapsulateCollection）。有个函数返回一个集合。让这个函数返回该集合的一个只读副本，并在这个类中提供添加 / 移除集合元素的函数。
12. **以数据类取代记录**（Replace Record with Data Class）。你需要面对传统编程环境中的记录结构。为该记录创建一个 “哑” 数据对象。
13. **以类取代类型码**（Replace Type Code withClass）。类之中有一个数值类行码，但它并不影响类的行为。以一个新的类替换该数值类型码。
14. **以子类取代类型码**（Replace Type Code withSubclass）。你又一个不可变的类型码，它会影响类的行为。以子类取代这个类型码。
15. **以 State/Strategy 取代类型码**（Replace Type Code withState/Strategy）。你有一个类型码，它会影响类的行为，但你无法通过继承手法消除它。以状态对象取代类型码。
16. **以字段取代子类**（Replace Subclass withFields）。你的各个子类的唯一差别只在 “返回常量数据” 的函数身上。修改这些函数，使他么返回超类中的某个（新增）字段，然后销毁子类。



## **11. 简化条件表达式**



1. **分解条件表达式**（DecomposeConditional）。你有一个复杂的条件（if-then-else）语句。从 if、then、else 三分段落中分别提炼出独立函数。
2. **合并条件表达式**（Consolidate ConditionalExpression）。你有一系列条件测试，都得到相同结果。将这些测试合并为一个条件表达式，并将这个条件表达式提炼成为一个独立函数。
3. **合并重复的条件片段**（Consolidate Duplicate ConditionalFragments）。在条件表达式的每个分支上有着相同的一段代码。将这段重复的代码搬移到条件表达式之外。
4. **移除控制标记**（Remove ControlFlag）。在一系列布尔表达式中，某个变量带有 “控制标记” 的作用。以 break 语句或 return 语句取代控制标记。
5. **以卫语句取代嵌套条件表达式**（Replace nested Conditional with GuardClauses）。函数中的条件逻辑使人难以看清正常的执行路径。使用卫语句表现所有的特殊情况。
6. **以多态取代条件表达式**（Replace Conditional withPolymorphism）。你手上有个条件表达式，它根据对象类型的不同选择不同的行为。将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数。
7. **引入 Null 对象**（Introduce Null Object）。你需要再三检查某对象是否为 null。将 null 值替换为 null 对象。
8. **引入断言**（Introduce Assertion）。某一段代码需要对程序状态做出某种假设。以断言明确表现这种假设。



## **12. 简化条件表达式**



1. **函数改名**（Rename Method）。函数的名称未能揭示函数的用途。修改函数的名称。
2. **添加参数**（Add Parameter）。某个函数需要从调用端得到更多信息。为此函数添加一个对象参数，让该对象带进函数所需信息。
3. **移除参数**（Remove Parameter）。函数本体不再需要某个参数。将该参数去除。
4. **将查询函数和修改函数分离**（Separate Query from Modifier）。某个函数既返回对象状态值，又修改对象状态。建立两个不同的函数，其中一个负责查询，另一个负责修改。
5. **令函数携带参数**（ParameterizeMethod）。若干函数做了类似的工作，但在函数本体中却包含了不同的值。建立单一函数，以参数表达那些不同的值。
6. **以明确函数取代参数**（Replace Parameter with ExplicitMethods）。你有一个函数，其中完全取决于参数值而采取不同行为。针对该参数的每一个可能值，建立一个独立函数。
7. **保持对象完整**（Preserve WholeObject）。你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。改为传递整个对象。
8. **以函数取代参数**（Replace Parameter withMethods）。对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能够调用前一个函数。让参数接受者去除该项参数，并直接调用前一个函数。
9. **引入参数对象**（Introduce Parameter Object）。某些参数总是很自然地同时出现。以一个对象取代这些参数。
10. **移除设值函数**（Remove Setting Method）。类中的某个字段应该在对象创建时被设值，然后就不再改变。去掉该字段的所有设值函数。
11. **隐藏函数**（Hide Method）。有一个函数，从来没有被其他任何类用到。将这个函数修改为 private。
12. **以工厂函数取代构造函数**（Replace Constructor with FactoryMethod）。你希望在创建对象时不仅仅是做简单的构建动作。将构建函数替换为工厂函数。
13. **封装向下转型**（Encapsulate Downcast）。某个函数返回的对象，需要由函数调用者执行向下转型。将向下转型动作移到函数中。
14. **以异常取代错误码**（Replace Error Code withException）。某个函数返回一个特定的代码，用以表示某种错误情况。改用异常。
15. **以测试取代异常**（Replace Exception withTest）。面对一个调用者可以预先检查的条件，你抛出了一个异常。修改调用者，使它在调用函数之前先做检查。

## **13. 处理概括关系**

1. **字段上移**（Pull Up Field）。两个子类拥有相同的字段。将该字段移至超类。
2. **函数上移**（Pull Up Method）。有些函数，在各个子类中产生完全相同的结果。将该函数移至超类。
3. **构造函数本体上移**（Pull Up ConstructorBody）。你在各个子类中拥有一些构造函数，他们的本体几乎完全一致。在超类中新建一个构造函数，并在子类构造函数中调用它。
4. **函数下移**（Push Down Method）。超类中的某个函数只与部分（而非全部）子类有关。将这个函数移到相关的那些子类去。
5. **字段下移**（Push Down Field）。超类中的某个字段只被部分（而非全部）子类用到。将这个字段移到需要它的那些子类去。
6. **提炼子类**（ExtractSubclass）。类中的某些特性只被某些（而非全部）实例用到。新建一个子类，将上面所说的那一部分特性移到子类中。
7. **提炼超类**（Extract Superclass）。两个类有相似特性。为这两个类建立一个超类，将相同特性移至超类。
8. **提炼接口**（ExtractInterface）。若干客户使用类接口中的同一子集，或者两个类的接口有部分相同。将相同的子集提炼到一个独立接口中。
9. **折叠继承体系**（Collapse Hierarchy）。超类和子类之间无太大差别。将它们合为一体。
10. **塑造模板函数**（Form TemPlateMethod）。你有一些子类，其中相应的某些函数以相同顺序执行类似的操作，但各个操作的细节上所有不同。将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。然后将原函数上移至超类。
11. **以委托取代继承**（Replace Inheritance withDelegation）。某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据。在子类中新建一个字段用以保存超类；调整子类函数令它改而委托超类；然后去掉两者之间的继承关系。
12. **以继承取代委托**（Replace Delegation withInheritance）。你在两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数。让委托类来继承受托类。

## **14. 大型重构** 

1. **梳理并分解继承体系**（Tease ApartInheritance）。某个继承体系同时承担两项责任。建立两个继承体系，并通过委托关系让其中一个可以调用另一个。
2. **将过程化设计转化为对象设计**（Convert Procedural Design toObjects）。你手上有一些传统过程化风格的代码。将数据记录变成对象，将大块的行为分成小块，并将行为移入相关对象之中。
3. **将领域和表述 / 显示分离**（Separate Domain fromPresentation）。某些 GUI 类之中包含了领域逻辑。将领域逻辑分离出来，为它们建立独立的领域类。
4. **提炼继承体系**（ExtractHierarchy）。你有某各类做了太多工作，其中一部分工作是以大量条件表达式完成的。建立继承体系，以一个子类表示一种特殊情况。

## 提炼函数

操作做法

- 创造一个新函数，根据这个函数的意图来对它命名。
- 将待提炼的代码从源函数复制到新建的目标函数中。
- 仔细检查提炼出的代码，看看其中是否引用了作用域限制源函数、在提炼出的新函数中访问不到的变量。
- 所有变量处理完毕后，编译。
- 在源函数中，将被提炼代码段替换为对目标函数的调用。
- 查看其它代码是否有与被提炼的代码段相同或相似之处。

代码展示

原代码

```
function printOwin(invoice) {
    printBanner();
    let outstanding = calculateOutstanding();
    
    // print details
    console.log(`name: ${invoice.customer}`);
    console.log(`amount: ${outstanding}`);
}
复制代码
```

新代码

```
function printOwin(invoice) {
    printBanner();
    let outstanding = calculateOutstanding();
    
    printDetails(invoice, outstanding);
}

function printDetails(invoice, outstanding) {
    console.log(`name: ${invoice.customer}`);
    console.log(`amount: ${outstanding}`);
}
复制代码
```

------

## 内联函数

操作做法

- 检查函数，确定它不具多态性。
- 找出这个函数的所有调用点。
- 将这个函数的所有调用点都替换为函数本体。
- 每次替换之后，执行测试。
- 删除该函数的定义。

代码展示

原代码

```
function getRating(driver) {
    return moreThanFiveLateDeliveries(driver) ? 2 : 1;
}

function moreThanFiveLateDeliveries(driver) {
    return driver.numberOfLateDeliveries > 5;
}
复制代码
```

新代码

```
function getRating(driver) {
    return (driver.numberOfLateDeliveries > 5) ? 2 : 1;
}
复制代码
```

------

## 提炼变量

操作做法

- 确认要提炼的表达式没有副作用。
- 声明一个不可修改的变量，把你想要提炼的表达式复制一份，以该表达式的结果值给这个变量赋值。
- 用这个新变量取代原来的表达式。
- 测试。

代码展示

原代码

```
return order.quantity * order.itemPrice - Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 + Math.min(order.quantity * order.itemPrice * 0.1, 100);
复制代码
```

新代码

```
const basePrice = order.quantity * order.itemPrice;
const quantityDiscount = Math.max(0, order.quantity - 500) * order.itemPrice * 0.05;
const shipping = Math.min(order.quantity * order.itemPrice * 0.1, 100);
return basePrice - quantityDiscount + shipping;
复制代码
```

------

## 内联变量

操作做法

- 检查确认变量赋值语句的右侧表达式没有副作用。
- 如果变量没有被声明为不可修改，先将其变为不可修改，并执行测试。
- 找到第一处使用该变量的地方，将其替换为直接使用赋值语句的右侧表达式。
- 测试。
- 重复前面两步，逐一替换其他所有使用该变量的地方。
- 删除该变量的声明点和赋值语句。
- 测试。

代码展示

原代码

```
let basePrice = anOrder.basePrice;
return (basePrice > 1000);
复制代码
```

新代码

```
return anOrder.basePrice > 1000;
复制代码
```

------

## 改变函数声明

操作做法

- 如果要移除一个参数，需要先确定函数体内没有使用该参数。
- 修改函数声明，使其成为你期望的状态。
- 找出所有使用旧的函数声明的地方，将它们改为使用新的函数声明。
- 测试。

代码展示

原代码

```
function circum(radius) {}
复制代码
```

新代码

```
function circumference(radius) {}
复制代码
```

------

## 封装变量

操作做法

- 创建封装函数，在其中访问和更新变量值。
- 执行静态检查。
- 逐一修改使用该变量的代码，将其改为调用合适的封装函数。每次替换之后，执行测试。
- 限制变量的可见性。
- 测试。
- 如果变量的值是一个记录，考虑使用`封装记录`。

代码展示

原代码

```
let defaultOwner = {firstName: 'Martin', lastName: 'Fowler'};
复制代码
```

新代码

```
let defaultOwner = {firstName: 'Martin', lastName: 'Fowler'};
export function defaultOwner() { return defaultOwnerData;}
export function setDefaultOwner(arg) { defaultOwnerData = arg; }
复制代码
```

------

## 变量改名

操作做法

- 如果变量被广泛使用，考虑运用`封装变量`将其封装起来。
- 找出所有使用该变量的代码，逐一修改。
- 测试。

代码展示

原代码

```
let a = height * width;
复制代码
```

新代码

```
let area = height * width;
复制代码
```

------

## 引入参数对象

操作做法

- 如果暂时还没有一个合适的数据结构，就创建一个。
- 测试。
- 使用`改变函数声明`给原来的函数新增一个参数，类型是新建的数据结构。
- 测试。
- 调整所有调用者，传入新数据结构的适当实例。
- 用新数据结构中的每项元素，逐一取代参数列表中与之对应的参数项，然后删除原来的参数。

代码展示

原代码

```
function amountInvoiced(startDate, endDate) {}
复制代码
```

新代码

```
function amountInvoiced(aDateRange) {}
复制代码
```

------

## 函数组合成类

操作做法

- 运用`封装记录`对多个函数共用的数据记录加以封装。
- 对于使用该记录结构的每个函数，运用`搬移函数`将其移入新类。
- 用以处理该数据记录的逻辑可以用`提炼函数`提炼出来，并移入新类。

代码展示

原代码

```
function base(aReading) {}
function taxableCharge(aReading) {}
function calculateBaseCharge(aReading) {}
复制代码
```

新代码

```
class Reading {
    base() {}
    taxableCharge() {}
    calculateBaseCharge() {}
}
复制代码
```

------

## 函数组合成变换

操作做法

- 创建一个变换函数，输入参数是需要变换的记录，并直接返回该记录的值。
- 挑选一块逻辑，将其主体移入变换函数中，把结果作为字段添加到输出记录中。修改客户端代码，令其使用这个新字段。
- 测试。
- 针对其他相关的计算逻辑，重复上述步骤。

代码展示

原代码

```
function base(aReading) {}
function taxableCharge(aReading) {}
复制代码
```

新代码

```
function enrichReading(argReading) {
    const aReading = _.cloneDeep(argReading);
    aReading.baseCharge = base(aReading);
    aReading.taxableCharge = taxableCharge(aReading);
    
    return aReading;
}
复制代码
```

------

## 拆分阶段

操作做法

- 将第二阶段的代码提炼成独立的函数。
- 测试。
- 引入一个中转数据结构，将其作为参数添加到提炼出的新函数的参数列表中。
- 测试。
- 逐一检查提炼出的“第二阶段函数”的每个参数。
- 对第一阶段的代码运用`提炼函数`，让提炼出的函数返回中转数据结构。

代码展示

原代码

```
const orderData = orderString.split(/\s+/);
const productPrice = priceList[orderData[0].split('-')[1]];
const orderPrice = parseInt(orderData[1]) * productPrice;
复制代码
```

新代码

```
const orderRecord = parseOrder(order);
const orderPrice = price(orderRecord, priceList);

function parseOrder(aString) {
    const values = aString.split(/\s+/);
    
    return ({
        productID: values[0].split('-')[1],
        quantity: parseInt(values[1])
    });
}

function price(order, priceList) {
    return order.quantity * priceList[order.productID];
}
复制代码
```

------

## 封装记录

操作做法

- 对持有记录的变量使用`封装变量`，将其封装到一个函数中。
- 创建一个类，将记录包装起来，并将记录变量的值替换为该类的一个实例。测试。
- 新建一个函数，让它返回该类的对象，而非那条原始的记录。
- 对于该记录的每处使用点，将原先返回记录的函数调用替换为那个返回实例对象的函数调用。
- 移除类对原始记录的访问函数，那个容易搜索的返回原始数据的函数也要一并删除。
- 测试。
- 如果记录中的字段本身也是复杂结构，考虑对其再次应用`封装记录`或`封装集合`手法。

代码展示

原代码

```
organization = {name: 'Acme Gooseberries', country: 'GB'};
复制代码
```

新代码

```
class Organization {
    constructor(data) {
        this._name = data.name;
        this._country = data.country;
    }
    
    get name() { return this._name;}
    set name(arg) { this._name = arg;}
    
    get country() { return this._country; }
    set country(arg) { this._country = arg; }
}
复制代码
```

------

## 封装集合

操作做法

- 如果集合的引用尚未被封装起来，先用`封装变量`封装它。
- 在类上添加用于“添加集合元素” 和 “移除集合元素”的函数。
- 执行静态检查。
- 查找集合的引用点。
- 修改集合的取值函数，使其返回一份只读的数据，可以使用只读代理或数据副本。
- 测试。

代码展示

原代码

```
class Person {
    get courses() { return this._courses; }
    set courses(aList) { this._courses = aList; }
}
复制代码
```

新代码

```
class Person {
    get courses() { return this._courses.slice(); }
    addCourse(aCourse) {}
    removeCourse(aCourse) {}
}
复制代码
```

------

## 以对象取代基本类型

操作做法

- 如果变量尚未封装起来，先使用`封装变量`封装它。
- 为这个数据值创建一个简单的类。
- 执行静态检查。
- 修改第一步得到的设值函数，令其创建一个新类的对象并将其存入字段，如果有必要的话，同时修改字段的类型声明。
- 修改取值函数，令其调用新类的取值函数，并返回结果。
- 测试。
- 考虑对第一步得到的访问函数使用`函数改名`，以变更好反映其用途。
- 考虑应用将`引用对象改为值对象`或将`对象改为引用对象`，明确指出新对象的角色是值对象还是引用对象。

代码展示

原代码

```
orders.filter(o => 'hight' === o.priority || 'rush' === o.priority);
复制代码
```

新代码

```
orders.filter(o => o.priority.higherThan(new Priority('normal')));
复制代码
```

------

## 以查询取代临时变量

操作做法

- 检查变量在使用前是否已经完全计算完毕，检查计算它的那段代码是否每次都能得到一样的值。
- 如果变量目前不是只读的，但是可以改造成只读变量，那就先改造它。
- 测试。
- 将为变量赋值的代码段提炼成函数。
- 测试。
- 应用`内联变量`手法移除临时变量。

代码展示

原代码

```
const basePrice = this._quantity * this._itemPrice;
if (basePrice > 1000)
    return basePrice * 0.95;
else
    return basePrice * 0.98;
复制代码
```

新代码

```
get basePrice() { this._quantity * this._itemPrice;}

if (this.basePrice > 1000)
    return this.basePrice * 0.95;
else 
    return this.basePrice * 0.98;
复制代码
```

------

## 提炼类

操作做法

- 决定如何分解类所负责的责任。
- 创建一个新的类，用以表现从旧类中分离出来的责任。
- 构造旧类时创建一个新类的实例，建立“从旧类访问新类”的连接关系。
- 对于你想搬移的每个字段，运用`搬移字段`搬移之。
- 使用`搬移函数`将必要函数搬移到新类。
- 检查两个类的接口，去掉不再需要的函数，必要时为函数重新取一个合适新环境的名字。
- 决定是否公开新的类。如果确实需要，考虑对新类应用`将引用对象改为值对象`使其成为一个值对象。

代码展示

原代码

```
class Person {
    get officeAreaCode() { return this._officeAreaCode;}
    get officeNumber() { return this._officeNumber;}
}
复制代码
```

新代码

```
class Person {
    get officeAreaCode() { return this._telephoneNumber.areaCode;}
    get officeNumber() { return this._telephoneNumber.number;}
}

class TelephoneNumber {
    get areaCode() { return this._areaCode; }
    get number() { return this._number; }
}
复制代码
```

------

## 内联类

操作做法

- 对于待内联类中所有public函数，在目标类上创建一个对应的函数，新创建的所有函数应该直接委托至源类。
- 修改源类public方法的所有引用点，令它们调用目标类对应的委托方法。每次更改后运行测试。
- 将源类中的函数与数据全部搬移到目标类，每次修改之后进行测试，直到源类变成空壳为止。
- 最后删除源类。

代码展示

原代码

```
class Person {
    get officeAreaCode() { return this._telephoneNumber.areaCode;}
    get officeNumber() { return this._telephoneNumber.number;}
}

class TelephoneNumber {
    get areaCode() { return this._areaCode; }
    get number() { return this._number; }
}
复制代码
```

新代码

```
class Person {
    get officeAreaCode() { return this._officeAreaCode;}
    get officeNumber() { return this._officeNumber;}
}
复制代码
```

------

## 隐藏委托关系

操作做法

- 对于每个委托关系中的函数，在服务对象端建立一个简单的委托函数。
- 调整客户端，令它只调用服务对象提供的函数。每次调整后运行测试。
- 如果将来不再有任何客户端需要取用Delegate（受托类），便可移除服务对象中的相关访问函数。
- 测试。

代码展示

原代码

```
manager = aPerson.department.manager;
复制代码
```

新代码

```
manager = aPerson.department;
class Person {
    get manager() { return this.department.manager; }
}
复制代码
```

------

## 移除中间人

操作做法

- 为受托对象创建一个取值函数。
- 对于每个委托函数，让其客户端转为连续的访问函数调用。
- 测试。

代码展示

原代码

```
manager = aPerson.department;
class Person {
    get manager() { return this.department.manager; }
}
复制代码
```

新代码

```
manager = aPerson.department.manager;
复制代码
```

------

## 替换算法

操作做法

- 整理一下待替换的算法，保证它已经被抽取到一个独立的函数中。
- 先只为这个函数准备测试，以便固定它的行为。
- 准备好另一个（替换用）算法。
- 执行静态检查。
- 运行测试，对比新旧算法的运行结果。

代码展示

原代码

```
function foundPerson(people) {
    for(let i = 0; i < people.length; i++) {
        if (people[i] === 'Don') {
            return 'Don';
        }
        
        if (people[i] === 'John') {
            return 'John';
        }
        
        if (people[i] === 'Kent') {
            return 'Kent';
        }
    }
    
    return '';
}
复制代码
```

新代码

```
function foundPerson(people) {
    const candidates = ['Don', 'John', 'Kent'];
    return people.find(p => candidates.includes(p)) || '';
}
复制代码
```

------

## 搬移函数

操作做法

- 检查函数在当前上下文里引用的所有程序元素（包括变量和函数），考虑是否需要将它们一并搬移。
- 检查待搬移函数是否具备多态性。
- 将函数复制一份到目标上下文中。
- 执行静态检查。
- 设法从源上下文中正确引用目标函数。
- 修改源函数，使之成为一个纯委托函数。
- 测试。
- 考虑对源函数使用`内联函数`。

代码展示

原代码

```
class Account {
    get overdraftCharge() {}
}
复制代码
```

新代码

```
class AccountType {
    get overdraftCharge() {}
}
复制代码
```

------

## 搬移字段

操作做法

- 确保源字段已经得到了良好封装。
- 测试。
- 在目标对象上创建一个字段。
- 执行静态检查。
- 确保源对象里能够正常引用目标对象。
- 调整源对象的访问函数，令其使用目标对象的字段。
- 测试。
- 移除源对象上的字段。
- 测试。

代码展示

原代码

```
class Customer {
    get plan() { return this._plan;}
    get discountRate() { return this._discountRate; }
}
复制代码
```

新代码

```
class Customer {
    get plan() { return this._plan;}
    get discountRate() { return this.plan._discountRate; }
}
复制代码
```

------

## 搬移语句到函数

操作做法

- 如果重复的代码段离调用目标函数的地方还有些距离，则先用`移动语句`将这些语句挪动到紧邻目标函数的位置。
- 如果目标函数仅被唯一一个函数调用，那么只需将源函数中的重复代码段剪切并粘贴到目标函数中即可，然后运行测试。
- 如果函数不止一个调用点，那么先选择其中一个调用点应用`提炼函数`,将待搬移的语句与目标函数一起提炼成一个新函数。给新函数取个临时的名字，只要易于搜索即可。
- 调整函数的其他调用点，令它们调用新提炼的函数。
- 完成所有引用点的替换后，应用`内联函数`将目标函数内联到新函数里，并移除原目标函数。
- 对新函数应用`函数改名`，将其改名为原目标函数的名字。

代码展示

原代码

```
result.push(`<p>title: ${person.photo.title}</p>`);
result.concat(photoData(person.photo));

function photoData(aPhoto) {
    return [
        `<p>location: ${aPhoto.location}</p>`,
        `<p>date: ${aPhoto.date.toDateString()}</p>`
    ];
}
复制代码
```

新代码

```
result.concat(photoData(person.photo));

function photoData(aPhoto) {
    return [
        `<p>title: ${person.photo.title}</p>`
        `<p>location: ${aPhoto.location}</p>`,
        `<p>date: ${aPhoto.date.toDateString()}</p>`
    ];
}
复制代码
```

------

## 搬移语句到调用者

操作做法

- 最简单的情况下，原函数非常简单，其调用者也只有寥寥一两个，此时只需要把要搬移的代码从函数里剪切出来并粘贴回调用端去即可，必要的时候做些调整。
- 若调用点不止一两个，则需要先用`提炼函数`，将你不想搬移的代码提炼成一个新函数，函数名可以临时起一个，只要后续容易搜索即可。
- 对原函数应用`内联函数`。
- 对提炼出来的函数应用`改变函数声明`，令其与原函数使用同一个名字。

代码展示

原代码

```
emitPhotoData(outStream, person.photo);

function emitPhotoData(outStream, photo) {
    outStream.write(`<p>title: ${photo.title}</p>\n`);
    outStream.write(`<p>location: ${photo.location}</p>\n`);
}
复制代码
```

新代码

```
emitPhotoData(outStream, person.photo);
outStream.write(`<p>location: ${person.photo.location}</p>\n`);

function emitPhotoData(outStream, photo) {
    outStream.write(`<p>title: ${photo.title}</p>\n`);
}
复制代码
```

------

## 以函数调用取代内联代码

操作做法

- 将内联代码替代为对一个既有函数的调用。
- 测试。

代码展示

原代码

```
let appliesToMass = false;
for(const s of states) {
    if (s === 'MA') appliesToMass = true;
}
复制代码
```

新代码

```
appliesToMass = states.includes('MA');
复制代码
```

------

## 移动语句

操作做法

- 确定待移动的代码片段应该被搬往何处。仔细检查待移动片段与目的地之间的语句，看看搬移后是否会影响这些代码正常工作。
- 剪切源代码片段，粘贴到上一步选定的位置上。
- 测试。

代码展示

原代码

```
const pricingPlan = retrievePricingPlan();
const order = retrieveOrder();

let charge;
const chargePerUnit = pricingPlan.unit;
复制代码
```

新代码

```
const pricingPlan = retrievePricingPlan();
const chargePerUnit = pricingPlan.unit;
const order = retrieveOrder();
let charge;
复制代码
```

------

## 拆分循环

操作做法

- 复制一遍循环代码。
- 识别并移除循环中的重复代码，使每个循环只做一件事。
- 测试。

代码展示

原代码

```
let averageAge = 0;
let totalSalary = 0;
for(const p of people) {
    averageAge += p.age;
    totalSalary += p.salary;
}

averageAge = averageAge / people.length;
复制代码
```

新代码

```
let totalSalary = 0;
for(const p of people) {
    totalSalary += p.salary;
}

let averageAge = 0;
for(const p of people) {
    averageAge += p.age;
}

averageAge = averageAge / people.length;
复制代码
```

------

## 以管道取代循环

操作做法

- 创建一个新变量，用以存放参与循环过程的集合。
- 从循环顶部开始，将循环里的每一块行为依次搬移出来，在上一步创建的集合变量上用一种管道运算替代之。
- 搬移完循环里的全部行为后，将循环整个删除。

代码展示

原代码

```
const names = [];
for (const i of input) {
    if (i.job === 'programmer')
        names.push(i.name);
}
复制代码
```

新代码

```
const names = input.filter(i => i.job === 'programmer').map(i => i.name);
复制代码
```

------

## 移除死代码

操作做法

- 如果死代码可以从外部直接引用，比如它是一个独立的函数时，先查找一下还有无调用点。
- 将死代码移除。
- 测试。

代码展示

原代码

```
if (false) {
   doSomethingThatUsedToMatter(); 
}
复制代码
```

新代码

```
复制代码
```

------

## 拆分变量

操作做法

- 在待分解变量的声明及第一次被赋值处，修改其名称。
- 如果可能的话，将新的变量声明为不可修改。
- 以该变量的第二次赋值动作为界，修改此前对该变量的所有引用，让它们引用新变量。
- 测试。
- 重复上述过程。每次都在声明处对变量改名，并修改下次赋值之前的引用，直至到达最后一处赋值。

代码展示

原代码

```
let temp = 2 * (height + width);
console.log(temp);
temp = height * width;
console.log(temp);
复制代码
```

新代码

```
const perimeter = 2 * (height + width);
console.log(perimeter);
const area = height * width;
console.log(area);
复制代码
```

------

## 字段改名

操作做法

- 如果记录的作用域较小，可以直接修改所有该字段的代码，然后测试。后面的步骤就都不需要了。
- 如果记录还未封装，请先使用`封装记录`.
- 在对象内部对私有字段改名，对应调整内部访问该字段的函数。
- 测试。
- 如果构造函数的参数用了旧的字段名，运用`改变函数声明`将其改名。
- 运用`函数改名`给访问函数改名。

代码展示

原代码

```
class Organization {
    get name() {}
}
复制代码
```

新代码

```
class Organization {
    get title() {}
}
复制代码
```

------

## 以查询取代派生变量

操作做法

- 识别出所有对变量做更新的地方。如有必要，用`拆分变量`分割各个更新点。
- 新建一个函数，用于计算该变量的值。
- 用`引入断言`断言该变量和计算函数始终给出同样的值。
- 测试。
- 修改读取该变量的代码，令其调用新建的函数。
- 测试。
- 用`移除死代码`去掉变量的声明和赋值。

代码展示

原代码

```
get discountedTotal() { return this._discountedTotal;}
set discount(aNumber) {
    const old = this._discount;
    this._discount = aNumber;
    this._discountedTotal += old - aNumber;
}
复制代码
```

新代码

```
get discountedTotal() { return this._baseTotal - this._discount; }
set discount(aNumber) { this._discount = aNumber; }
复制代码
```

------

## 将引用对象改为值对象

操作做法

- 检查重构目标是否为不可变对象，或者是否可修改为不可变对象。
- 用`移除设值函数`逐一去掉所有设值函数。
- 提供一个基于值的相等性判断函数，在其中使用值对象的字段。

代码展示

原代码

```
class Product {
    applyDiscount(arg) { this._price.amount -= arg; }
}
复制代码
```

新代码

```
class Product {
    applyDiscount(arg) { 
        this._price = new Money(this._price.amount - arg, this._price.currency);
    }
}
复制代码
```

------

## 将值对象改为引用对象

操作做法

- 为相关对象创建一个仓库。
- 确保构造函数有办法找到关联对象的正确实例。
- 修改宿主对象的构造函数，令其从仓库中获取关联对象。每次修改后执行测试。

代码展示

原代码

```
let customer = new Customer(customerData);
复制代码
```

新代码

```
let customer = customerRepository.get(customerData.id);
复制代码
```

------

## 分解条件表达式

操作做法

- 对条件判断和每个条件分支分别运用`提炼函数`手法。

代码展示

原代码

```
if (!aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd))
    charge = quantity * plan.summerRate;
else 
    charge = quantity * plan.regularRate + plan.regularServiceCharge;
复制代码
```

新代码

```
if (summer())
    charge = summer();
else
    charge = regularCharge();
复制代码
```

------

## 合并条件表达式

操作做法

- 确定这些条件表达式都没有副作用。
- 使用适当的逻辑运算符，将两个相关条件表达式合并为一个。
- 测试。
- 重复前面的合并过程，直到所有相关的条件表达式都合并到一起。
- 可以考虑对合并后的条件表达式实施`提炼函数`。

代码展示

原代码

```
if (anEmployee.seniority < 2) return 0;
if (anEmployee.monthsDisabled > 12) return 0;
if (anEmployee.isPartTime) return 0;
复制代码
```

新代码

```
if (isNotEligibleForDisability()) return 0;

function isNotEligibleForDisability() {
    return ((anEmployee.seniority < 2) || (anEmployee.monthsDisabled > 12) || (anEmployee.isPartTime));
}
复制代码
```

------

## 以卫语句取代嵌套条件表达式

操作做法

- 选中最外层需要被替换的条件逻辑，将其替换为卫语句。
- 测试。
- 有需要的话，重复上述步骤。
- 如果所有卫语句都引发同样的结果，可以使用`合并条件表达式`合并之。

代码展示

原代码

```
function getPayAmount() {
    let result;
    if (isDead)
        result = deadAmount();
    else {
        if (isSeparated)
            result = separatedAmount();
        else {
            if (isRetired)
                result = retiredAmount();
            else
                result = normalPayAmount();
        }
    }
    return result;
}
复制代码
```

新代码

```
function getPayAmount() {
    if (isDead) return deadAmount();
    if (isSeparated) return separatedAmount();
    if (isRetired) return retiredAmount();
    
    return normalPayAmount();
}
复制代码
```

------

## 以多态取代条件表达式

操作做法

- 如果现有的类尚不具备多态行为，就用工厂函数创建之，令工厂函数返回恰当的对象实例。
- 在调用方代码中使用工厂函数获得对象实例。
- 将带有条件逻辑的函数移到超类中。
- 任选一个子类，在其中建立一个函数，使之覆写超类中容纳条件表达式的那个函数。将与该子类相关的条件表达式分支复制到新函数中，并对它进行适当调整。
- 重复上述过程，处理其他条件分支。
- 在超类函数中保留默认情况的逻辑。

代码展示

原代码

```
switch (bird.type) {
    case 'EuropeanSwallow':
        return 'average';
    case 'AfricanSwallow':
        return (bird.numberOfCoconuts > 2) ? 'tired' : 'average';
    case 'NorwegianBlueParrot':
        return (bird.voltage > 100) ? 'scorched' : 'beautiful';
    default:
        return 'unknown';
}
复制代码
```

新代码

```
class EuropeanSwallow {
    get plumage() {
        return 'average';
    }
}

class AfricanSwallow {
    get plumage() {
        return (this.numberOfCoconuts > 2) ? 'tired' : 'average';
    }
}

class NorwegianBlueParrot {
    get plumage() {
        return (this.voltage > 100) ? 'scorched' : 'beautiful';
    }
}
复制代码
```

------

## 以多态取代条件表达式

操作做法

- 如果现有的类尚不具备多态行为，就用工厂函数创建之，令工厂函数返回恰当的对象实例。
- 在调用方代码中使用工厂函数获得对象实例。
- 将带有条件逻辑的函数移到超类中。
- 任选一个子类，在其中建立一个函数，使之覆写超类中容纳条件表达式的那个函数。将与该子类相关的条件表达式分支复制到新函数中，并对它进行适当调整。
- 重复上述过程，处理其他条件分支。
- 在超类函数中保留默认情况的逻辑。

代码展示

原代码

```
switch (bird.type) {
    case 'EuropeanSwallow':
        return 'average';
    case 'AfricanSwallow':
        return (bird.numberOfCoconuts > 2) ? 'tired' : 'average';
    case 'NorwegianBlueParrot':
        return (bird.voltage > 100) ? 'scorched' : 'beautiful';
    default:
        return 'unknown';
}
复制代码
```

新代码

```
class EuropeanSwallow {
    get plumage() {
        return 'average';
    }
}

class AfricanSwallow {
    get plumage() {
        return (this.numberOfCoconuts > 2) ? 'tired' : 'average';
    }
}

class NorwegianBlueParrot {
    get plumage() {
        return (this.voltage > 100) ? 'scorched' : 'beautiful';
    }
}
复制代码
```

------

## 引入特例

操作做法

- 给重构目标添加检查特例的属性，令其返回false。
- 创建一个特例对象，其中只有检查特例的属性，返回true。
- 对“与特例值做对比”的代码运用`提炼函数`，确保所有客户端都使用这个新函数，而不再直接做特例值的比对。
- 将新的特例对象引入代码中，可以从函数调用中返回，也可以在变换函数中生成。
- 修改特例比对函数的主体，在其中直接使用检查特例的属性。
- 测试。
- 使用`函数组合成类`或`函数组合成变换`,把通用的特例处理逻辑都搬移到新建的特例对象中。
- 对特例比对函数使用`内联函数`，将其内联到仍然需要的地方。

代码展示

原代码

```
if (aCustomer === 'unknown') customerName = 'occupant';
复制代码
```

新代码

```
class UnknownCustomer {
    get name() {
        return 'occupant';
    }
}
复制代码
```

------

## 引入断言

操作做法

- 如果你发现代码假设某个条件始终为真，就加入一个断言明确说明这种情况。因为断言应该不会对系统运行造成任何影响，所以“加入断言”永远都应该是行为保持的。

代码展示

原代码

```
if (this.discountRate)
    base = base - (this.discountRate * base);
复制代码
```

新代码

```
assert(this.discountRate >= 0);
if (this.discountRate)
    base = base - (this.discountRate * base);
复制代码
```

------

## 将查询函数和修改函数分离

操作做法

- 复制整个函数，将其作为一个查询来命名。
- 从新建的查询函数中去掉所有造成副作用的语句。
- 执行静态检查。
- 查找所有调用原函数的地方。如果调用处用到了该函数的返回值，就将其改为调用新建的查询函数，并在下面马上再调用一次原函数。每次修改之后都要测试。
- 从原函数中去掉返回值。
- 测试。

代码展示

原代码

```
function getTotalOutstandingAndSendBill() {
    const result = customer.invoices.reduce((total, each) => each.amount + total, 0);
    sendBill();
    return result;
}
复制代码
```

新代码

```
function totalOutstanding() {
    return customer.invoices.reduce((total, each) => each.amount + total, 0);
}

function sendBill() {
    emailGateway.send(formatBill(customer));
}
复制代码
```

------

## 函数参数化

操作做法

- 从一组相似的函数中选择一个。
- 运用`改变函数声明`，把需要作为参数传入的字面量添加到参数列表中。
- 修改该函数所有的调用处，使其在调用时传入该字面量值。
- 测试。
- 修改函数体，令其使用新传入的参数。每使用一个新参数都要测试。
- 对于其他与之相似的函数，逐一将其调用处改为调用已经参数化的函数。每次修改后都要测试。

代码展示

原代码

```
function tenPercentRaise(aPerson) {
    aPerson.salary = aPerson.salary.multiply(1.1);
}

function fivePercentRaise(aPerson) {
    aPerson.salary = salary.salary.multiply(1.05);
}
复制代码
```

新代码

```
function raise(aPerson, factor) {
    aPerson.salary = salary.salary.multiply(1 + factor);
}
复制代码
```

------

## 移除标记参数

操作做法

- 针对参数的每一种可能值，新建一个明确函数。
- 对于“用字面量值作为参数”的函数调用者，将其改为调用新建的明确函数。

代码展示

原代码

```
function setDimension(name, value) {
    if (name === 'height') {
        this._height = value;
        return;
    }
    
    if (name === 'width') {
        this._width = value;
        return;
    }
}
复制代码
```

新代码

```
function setHeight(value) {
    this._height = value;
    this._width = value;
}
复制代码
```

------

## 保持对象完整

操作做法

- 新建一个空函数，给它以期望中的参数列表（即传入完整对象作为参数）。
- 在新函数体内调用旧函数，并把新的参数（即完整对象）映射到旧的参数列表（即来源于完整对象的各项数据）。
- 执行静态检查。
- 逐一修改旧函数的调用者，令其使用新函数，每次修改之后执行测试。
- 所有调用处都修改过来之后，使用`内联函数`把旧函数内联到新函数体内。
- 给新函数改名，从重构开始时的容易搜索的临时名字，改为使用旧函数的名字，同时修改所有调用处。

代码展示

原代码

```
const low = aRoom.daysTempRange.low;
const high = aRoom.daysTempRange.high;
if (aPlan.withinRange(low, high))
复制代码
```

新代码

```
if (aPlan.withinRange(aRoom.daysTempRange))
复制代码
```

------

## 以查询取代参数

操作做法

- 如果有必要，使用`提炼函数`将参数的计算过程提炼到一个独立的函数中。
- 将函数体内引用该参数的地方改为调用新建的函数。每次修改后执行测试。
- 全部替换完成后，使用`改变函数声明`将该参数去掉。

代码展示

原代码

```
availableVacation(anEmployee, anEmployee.grade);

function availableVacation(anEmployee, grade) {}
复制代码
```

新代码

```
availableVacation(anEmployee);

function availableVacation(anEmployee) {
    const grade = anEmployee.grade;
}
复制代码
```

------

## 以参数取代查询

操作做法

- 对执行查询操作的代码使用`提炼变量`，将其从函数体中分离出来。
- 现在函数体代码已经不再执行查询操作，对这部分代码使用`提炼函数`。
- 使用`内联变量`，消除刚才提炼出来的变量。
- 对原来的函数使用`内联函数`。
- 对新函数改名，改回原来函数的名字。

代码展示

原代码

```
targetTemperature(aPlan);

function targetTemperature(aPlan) {
    currentTemperature = thermostat.currentTemperature;
}
复制代码
```

新代码

```
targetTemperature(aPlan, thermostat.currentTemperature);

function targetTemperature(aPlan, currentTemperature) {}
复制代码
```

------

## 移除设值函数

操作做法

- 如果构造函数尚无法得到想要设入字段的值，就使用`改变函数声明`将这个值以参数的形式传入构造函数。在构造函数中调用设值函数，对字段设值。
- 移除所有在构造函数之外对设值函数的调用，改为使用新的构造函数。每次修改之后都要测试。
- 使用`内联函数`消去设值函数。如果可能的话，把字段声明为不可变。
- 测试。

代码展示

原代码

```
class Person {
    get name() {}
    set name(aString) {}
}
复制代码
```

新代码

```
class Person {
    get name() {}
}
复制代码
```

------

## 以工厂函数取代构造函数

操作做法

- 新建一个工厂函数，让它调用现有的构造函数。
- 将调用构造函数的代码改为调用工厂函数。
- 每修改一处，就执行测试。
- 尽量缩小构造函数的可见范围。

代码展示

原代码

```
leadEngineer = new Employee(document.leadEngineer, 'E');
复制代码
```

新代码

```
leadEngineer = createEmployeer(document.leadEngineer);
复制代码
```

------

## 以命令取代函数

操作做法

- 为想要包装的函数创建一个空的类，根据该函数的名字为其命名。
- 使用`搬移函数`把函数移到空的类里。
- 可以考虑给每个参数创建一个字段，并在构造函数中添加对应的参数。

代码展示

原代码

```
function score(candidate, medicalExam, scoringGuide) {
    let result = 0;
    let healthLevel = 0;
}
复制代码
```

新代码

```
class Scorer {
    constructor(candidate, medicalExam, scoringGuide) {
        this._candidate = candidate;
        this._medicalExam = medicalExam;
        this._scoringGuide = scoringGuide;
    }
    
    execute() {
        this._result = 0;
        this._healthLevel = 0;
    }
}
复制代码
```

------

## 以函数取代命令

操作做法

- 运用`提炼函数`，把“创建并执行命令对象”的代码单独提炼到一个函数中。
- 对命令对象在执行阶段用到的函数，逐一使用`内联函数`。
- 使用`改变函数声明`，把构造函数的参数转移到执行函数。
- 对于所有的字段，在执行函数中找到引用它们的地方，并改为使用参数。每次修改后都要测试。
- 把“调用构造函数”和“调用执行函数”两步都内联到调用方。
- 测试。
- 用`移除死代码`把命令类消去。

代码展示

原代码

```
class ChargeCalculator {
    constructor(customer, usage) {
        this._customer = customer;
        this._usage = usage;
    }
    
    execute() {
        return this._customer.rate * this._usage;
    }
}

复制代码
```

新代码

```
function charge(customer, usage) {
    return customer.rate * usage;
}
复制代码
```

------

## 函数上移

操作做法

- 检查待提升函数，确定它们是完全一致的。
- 检查函数体内引用的所有函数调用和字段都能从超类中调用到。
- 如果待提升函数的签名不同，使用`改变函数声明`将那些签名都修改为你想要在超类中使用的签名。
- 在超类中新建一个函数，将某一个待提升函数的代码复制到其中。
- 执行静态检查。
- 移除一个待提升的子类函数。
- 测试。
- 逐一移除待提升的子类函数，直到只剩下超类中的函数为止。

代码展示

原代码

```
class Employee {}

class Salesman extends Employee {
    get name() {}
}

class Engineer extends Employee {
    get name() {}
}
复制代码
```

新代码

```
class Employee {
    get name() {}
}

class Salesman extends Employee {}
class Engineer extends Employee {}
复制代码
```

------

## 字段上移

操作做法

- 针对待提升字段，检查它们的所有使用点，确认它们以同样的方式被使用。
- 如果这些字段的名称不同，先使用`变量改名` 为它们取个相同的名字。
- 在超类中新建一个字段。
- 移除子类中的字段。
- 测试。

代码展示

原代码

```
class Employee {} //Java

class Salesman extends Employee {
    private String name;
}

class Engineer extends Employee {
    private String name;
}
复制代码
```

新代码

```
class Employee {
    protected String name;
}

class Salesman extends Employee {}
class Engineer extends Employee {}
复制代码
```

------

## 构造函数本体上移

操作做法

- 如果超类还不存在构造函数，首先为其定义一个。确保让子类调用超类的构造函数。
- 使用`移动语句`将子类中构造函数的的公共语句移动到超类的构造函数调用语句之后。
- 逐一移除子类间的公共代码，将其提升至超类构造函数中。对于公共代码中引用到的变量，将其作为参数传递给超类的构造函数。
- 测试。
- 如果存在无法简单提升至超类的公共代码，先应用`提炼函数`，再利用`函数上移`提升。

代码展示

原代码

```
class Party {}

class Employee extends Party {
    constructor(name, id, monthlyCost) {
        super();
        this._id = id;
        this._name = name;
        this._monthlyCost = monthlyCost;
    }
}
复制代码
```

新代码

```
class Party {
    constructor(name) {
        this._name = name;
    }
}

class Employee extends Party {
    constructor(name, id, monthlyCost) {
        super(name);
        this._id = id;
        this._monthlyCost = monthlyCost;
    }
}
复制代码
```

------

## 函数下移

操作做法

- 将超类中的函数本体复制到每一个需要此函数的子类中。
- 删除超类中的函数。
- 测试。
- 将该函数从所有不需要它的那些子类中删除。
- 测试。

代码展示

原代码

```
class Employee {
    get quota {}
}

class Engineer extends Employee {}
class Salesman extends Employee {}
复制代码
```

新代码

```
class Employee {}

class Engineer extends Employee {}
class Salesman extends Employee {
    get quota {}
}
复制代码
```

------

## 字段下移

操作做法

- 在所有需要该字段的子类中声明该字段。
- 将该字段从超类中移除。
- 测试。
- 将该字段从所有不需要它的那些子类中删掉。
- 测试。

代码展示

原代码

```
class Employee { // Java
    private String quota;
}

class Engineer extends Employee {}
class Salesman extends Employee {}
复制代码
```

新代码

```
class Employee {}
class Engineer extends Employee {}

class Salesman extends Employee {
    protected String quota;
}
复制代码
```

------

## 以子类取代类型码

操作做法

- 自封装类型码字段。
- 任选一个类型码取值，为其创建一个子类。覆写类型码类的取值函数，令其返回该类型码的字面量值。
- 创建一个选择器逻辑，把类型码参数映射到新的子类。
- 测试。
- 针对每个类型码取值，重复上述“创建子类、添加选择器逻辑”的过程。
- 去除类型码字段。
- 测试。
- 使用`函数下移`和`以多态取代条件表达式`处理原本访问了类型码的函数。

代码展示

原代码

```
function createEmployee(name, type) {
    return new Employee(name, type);
}
复制代码
```

新代码

```
function createEmployee(name, type) {
    switch (type) {
        case 'engineer': return new Engineer(name);
        case 'salesman': return new Salesman(name);
        case 'manager': return new Manager(name);
    }
}
复制代码
```

------

## 移除子类

操作做法

- 使用`以工厂函数取代构造函数`，把子类的构造函数包装到超类的工厂函数中。
- 如果有任何代码检查子类的类型，先用`提炼函数`把类型检查逻辑包装起来，然后用`搬移函数`将其搬到超类。
- 新建一个字段，用于代表子类的类型。
- 将原本针对子类的类型做判断的函数改为使用新建的类型字段。
- 删除子类。
- 测试。

代码展示

原代码

```
class Person {
    get genderCode() { return 'X';}
}

class Male extends Person {
    get genderCode() { return 'M';}
}

class Female extends Person {
    get genderCode() { return 'F';}
}
复制代码
```

新代码

```
class Person {
    get genderCode() { return this._genderCode;}
}
复制代码
```

------

## 提炼超类

操作做法

- 为原本的类新建一个空白的超类。
- 测试。
- 使用`构造函数本体上移`、`函数上移`和`字段上移`手法，逐一将子类的共同元素上移到超类。
- 检查留在子类中的函数，看它们是否还有共同的成分。如果有，可以先用`提炼函数`将其提炼出来，再用`函数上移`搬到超类。
- 检查所有使用原本的类的客户端代码，考虑将其调整为使用超类的接口。

代码展示

原代码

```
class Department {
    get totalAnnualCost() {}
    get name() {}
    get headCount() {}
}

class Employee {
    get annualCost() {}
    get name() {}
    get id() {}
}
复制代码
```

新代码

```
class Party {
    get name() {}
    get annualCost() {}
}

class Department extends Party {
    get annualCost() {}
    get headCount() {}
}

class Employee extends Party {
    get annualCost() {}
    get id() {}
}
复制代码
```

------

## 折叠继承体系

操作做法

- 选择想移除的类：是超类还是子类？
- 使用`字段上移`、`字段下移`、`函数上移`、`函数下移`把所有元素都移到同一个类中。
- 调整即将被移除的那个类的所有引用点，令它们改而引用合并后留下的类。
- 移除我们的目标；
- 测试。

代码展示

原代码

```
class Employee {}
class Salesman extends Employee {}
复制代码
```

新代码

```
class Employee {}
复制代码
```

------

## 以委托取代子类

操作做法

- 如果构造函数有多个调用者，首先用`以工厂函数取代构造函数`把构造函数包装起来。
- 创建一个空的委托类，这个类的构造函数应该接受所有子类特有的数据项，并且经常以参数的形式接受一个指回超类的引用。
- 在超类中添加一个字段，用于安放委托对象。
- 修改子类的创建逻辑，使其初始化上述委托字段，放入一个委托对象的实例。
- 选择一个子类中的函数，将其移入委托类。
- 使用`搬移函数`手法搬移上述函数，不要删除源类中的委托代码。
- 如果被搬移的源函数还在子类之外被调用了，就把留在源类中的委托代码从子类移到超类，并在委托代码之前加上卫语句，检查委托对象存在。如果子类之外已经没有其他调用者，就用`移除死代码`去掉已经没人使用的委托代码。
- 测试。
- 重复上述过程，直到子类中所有函数都搬到委托类。
- 找到所有调用子类构造函数的地方，逐一将其改为使用超类的构造函数。
- 测试。
- 运用`移除死代码`去掉子类。

代码展示

原代码

```
class Order {
    get daysToShip() {
        return this._warehouse.daysToShip;
    }
}

class PriorityOrder extends Order {
    get daysToShip() {
        return this._priorityPlan.daysToShip;
    }
}
复制代码
```

新代码

```
class Order {
    get daysToShip() {
        return (this._priorityDelegate) ? this._priorityDelegate.daysToShip : this._warehouse.daysToShip;
    }
}

class PriorityOrderDelegate {
    get daysToShip() {
        return this._priorityPlan.daysToShip;
    }
}
复制代码
```

------

## 以委托取代超类

操作做法

- 在子类中新建一个字段，使其引用超类的一个对象，并将这个委托引用初始化为超类的新实例。
- 针对超类的每个函数，在子类中创建一个转发函数，将调用请求转发给委托引用。
- 当所有超类函数都转发函数覆写后，就可以去掉继承关系。

代码展示

原代码

```
class List {}
class Stack extends List {}
复制代码
```

新代码

```
class Stack {
    constructor() {
        this._storage = new List();
    }
}

class List {}
```


作者：轻松学编程
链接：https://juejin.im/post/6844903953067409416





[Hawstein's Blog](http://hawstein.com/)

- [HOME](http://hawstein.com/)
- [ABOUT](http://hawstein.com/about/)
- [ARCHIVE](http://hawstein.com/archive/)
- [PORTFOLIO](http://hawstein.com/portfolio/)

[Java](http://hawstein.com/archive/?tag=Java)

# Google Java 编程风格指南

## 

*Hawstein | January 20, 2014*

## 目录

1. [前言](http://hawstein.com/2014/01/20/google-java-style/#Intro)
2. [源文件基础](http://hawstein.com/2014/01/20/google-java-style/#SFBasic)
3. [源文件结构](http://hawstein.com/2014/01/20/google-java-style/#SFStruct)
4. [格式](http://hawstein.com/2014/01/20/google-java-style/#Format)
5. [命名约定](http://hawstein.com/2014/01/20/google-java-style/#Naming)
6. [编程实践](http://hawstein.com/2014/01/20/google-java-style/#Practice)
7. [Javadoc](http://hawstein.com/2014/01/20/google-java-style/#Javadoc)
8. [后记](http://hawstein.com/2014/01/20/google-java-style/#End)

## 前言

这份文档是Google Java编程风格规范的完整定义。当且仅当一个Java源文件符合此文档中的规则， 我们才认为它符合Google的Java编程风格。

与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题， 同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则， 对于那些不是明确强制要求的，我们尽量避免提供意见。

### 1.1 术语说明

在本文档中，除非另有说明：

1. 术语class可表示一个普通类，枚举类，接口或是annotation类型(`@interface`)
2. 术语comment只用来指代实现的注释(implementation comments)，我们不使用“documentation comments”一词，而是用Javadoc。

其他的术语说明会偶尔在后面的文档出现。

### 1.2 指南说明

本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循Google编程风格，但并不意味着这是展现这些代码的唯一方式。 示例中的格式选择不应该被强制定为规则。

## 源文件基础

### 2.1 文件名

源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为`.java`。

### 2.2 文件编码：UTF-8

源文件编码格式为UTF-8。

### 2.3 特殊字符

#### 2.3.1 空白字符

除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：

1. 所有其它字符串中的空白字符都要进行转义。
2. 制表符不用于缩进。

#### 2.3.2 特殊转义序列

对于具有特殊[转义序列](http://zh.wikipedia.org/wiki/转义序列)的任何字符(\b, \t, \n, \f, \r, ", '及\)，我们使用它的转义序列，而不是相应的八进制(比如`\012`)或Unicode(比如`\u000a`)转义。

#### 2.3.3 非ASCII字符

对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解。

> Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。

例如：

```
1 2 3 4 5 String unitAbbrev = "μs";                                 | 赞，即使没有注释也非常清晰 String unitAbbrev = "\u03bcs"; // "μs"                    | 允许，但没有理由要这样做 String unitAbbrev = "\u03bcs"; // Greek letter mu, "s"    | 允许，但这样做显得笨拙还容易出错 String unitAbbrev = "\u03bcs";                            | 很糟，读者根本看不出这是什么 return '\ufeff' + content; // byte order mark             | Good，对于非打印字符，使用转义，并在必要时写上注释 
```

> Tip: 永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行， 你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话)

## 源文件结构

一个源文件包含(按顺序地)：

1. 许可证或版权信息(如有需要)
2. package语句
3. import语句
4. 一个顶级类(**只有一个**)

以上每个部分之间用一个空行隔开。

### 3.1 许可证或版权信息

如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。

### 3.2 package语句

package语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里)

### 3.3 import语句

#### 3.3.1 import不要使用通配符

即，不要出现类似这样的import语句：`import java.util.*;`

#### 3.3.2 不要换行

import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行)

#### 3.3.3 顺序和间距

import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：

1. 所有的静态导入独立成组
2. `com.google` imports(仅当这个源文件是在`com.google`包下)
3. 第三方的包。每个顶级包为一组，字典序。例如：android, com, junit, org, sun
4. `java` imports
5. `javax` imports

组内不空行，按字典序排列。

### 3.4 类声明

#### 3.4.1 只有一个顶级类声明

每个顶级类都在一个与它同名的源文件中(当然，还包含`.java`后缀)。

例外：`package-info.java`，该文件中可没有`package-info`类。

#### 3.4.2 类成员顺序

类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。

##### 3.4.2.1 重载：永不分离

当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。

## 格式

**术语说明**：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。

### 4.1 大括号

#### 4.1.1 使用大括号(即使是可选的)

大括号与`if, else, for, do, while`语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。

#### 4.1.2 非空块：K & R 风格

对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格 ([Egyptian brackets](http://www.codinghorror.com/blog/2012/07/new-programming-jargon.html)):

- 左大括号前不换行
- 左大括号后换行
- 右大括号前换行
- 如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。

示例：

```
1 2 3 4 5 6 7 8 9 10 11 return new MyClass() {  @Override public void method() {    if (condition()) {      try {        something();      } catch (ProblemException e) {        recover();      }    }  } }; 
```

4.8.1节给出了enum类的一些例外。

#### 4.1.3 空块：可以用简洁版本

一个空的块状结构里什么也不包含，大括号可以简洁地写成`{}`，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要换行。

示例：

```
1 void doNothing() {} 
```

### 4.2 块缩进：2个空格

每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)

### 4.3 一行一个语句

每个语句后要换行。

### 4.4 列限制：80或100

一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。

例外：

1. 不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。
2. `package`和`import`语句(见3.2节和3.3节)。
3. 注释中那些可能被剪切并粘贴到shell中的命令行。

### 4.5 自动换行

**术语说明**：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。

我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。

> Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)

#### 4.5.1 从哪里断开

自动换行的基本准则是：更倾向于在更高的语法级别处断开。

1. 如果在`非赋值运算符`处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。 这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&（`<T extends Foo & Bar>`)，catch块中的管道符号(`catch (FooException | BarException e`)
2. 如果在`赋值运算符`处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于`foreach`语句中的分号。
3. 方法名或构造函数名与左括号留在同一行。
4. 逗号(,)与其前面的内容留在同一行。

#### 4.5.2 自动换行时缩进至少+4个空格

自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。

当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。

第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。

### 4.6 空白

#### 4.6.1 垂直空白

以下情况需要使用一个空行：

1. 类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。
   - **例外**：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。
2. 在函数体内，语句的逻辑分组间使用空行。
3. 类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。
4. 要满足本文档中其他节的空行要求(比如3.3节：import语句)

多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。

#### 4.6.2 水平空白

除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：

1. 分隔任何保留字与紧随其后的左括号(`(`)(如`if, for catch`等)。

2. 分隔任何保留字与其前面的右大括号(`}`)(如`else, catch`)。

3. 在任何左大括号前(

   ```plaintext
   {
   ```

   )，两个例外：

   - `@SomeAnnotation({a, b})`(不使用空格)。
   - `String[][] x = foo;`(大括号间没有空格，见下面的Note)。

4. 在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：

   - 类型界限中的&(`<T extends Foo & Bar>`)。
   - catch块中的管道符号(`catch (FooException | BarException e`)。
   - `foreach`语句中的分号。

5. 在`, : ;`及右括号(`)`)后

6. 如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。

7. 类型和变量之间：List list。

8. 数组初始化中，大括号内的空格是可选的，即`new int[] {5, 6}`和`new int[] { 5, 6 }`都是可以的。

> Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。

#### 4.6.3 水平对齐：不做要求

**术语说明**：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。

这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。

以下示例先展示未对齐的代码，然后是对齐的代码：

```
1 2 3 4 5 private int x; // this is fine private Color color; // this too private int   x;      // permitted, but future edits private Color color;  // may leave it unaligned 
```

> Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。

### 4.7 用小括号来限定组：推荐

除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。

### 4.8 具体结构

#### 4.8.1 枚举类

枚举常量间用逗号隔开，换行可选。

没有方法和文档的枚举类可写成数组初始化的格式：

```
1 private enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS } 
```

由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。

#### 4.8.2 变量声明

##### 4.8.2.1 每次只声明一个变量

不要使用组合声明，比如`int a, b;`。

##### 4.8.2.2 需要时才声明，并尽快进行初始化

不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。

#### 4.8.3 数组

##### 4.8.3.1 数组初始化：可写成块状结构

数组初始化可以写成块状结构，比如，下面的写法都是OK的：

```
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 new int[] {  0, 1, 2, 3  } new int[] {  0,  1,  2,  3 } new int[] {  0, 1,  2, 3 } new int[]{0, 1, 2, 3} 
```

##### 4.8.3.2 非C风格的数组声明

中括号是类型的一部分：`String[] args`， 而非`String args[]`。

#### 4.8.4 switch语句

**术语说明**：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(`case FOO:`或`default:`)，后面跟着一条或多条语句。

##### 4.8.4.1 缩进

与其它块状结构一致，switch块中的内容缩进为2个空格。

每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。

##### 4.8.4.2 Fall-through：注释

在一个switch块内，每个语句组要么通过`break, continue, return`或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用`// fall through`)。这个特殊的注释并不需要在最后一个语句组(一般是`default`)中出现。示例：

```
1 2 3 4 5 6 7 8 9 10 11 switch (input) {  case 1:  case 2:    prepareOneOrTwo();    // fall through  case 3:    handleOneTwoOrThree();    break;  default:    handleLargeNumber(input); } 
```

##### 4.8.4.3 default的情况要写出来

每个switch语句都包含一个`default`语句组，即使它什么代码也不包含。

#### 4.8.5 注解(Annotations)

注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。例如：

```
1 2 3 @Override @Nullable public String getNameIfPresent() { ... } 
```

**例外**：单个的注解可以和签名的第一行出现在同一行。例如：

```
1 @Override public int hashCode() { ... } 
```

应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：

```
1 @Partial @Mock DataLoader loader; 
```

参数和局部变量注解没有特定规则。

#### 4.8.6 注释

##### 4.8.6.1 块注释风格

块注释与其周围的代码在同一缩进级别。它们可以是`/* ... */`风格，也可以是`// ...`风格。对于多行的`/* ... */`注释，后续行必须从`*`开始， 并且与前一行的`*`对齐。以下示例注释都是OK的。

```
1 2 3 4 /* * This is          // And so           /* Or you can * okay.            // is this.          * even do this. */ */ 
```

注释不要封闭在由星号或其它字符绘制的框架里。

> Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用 `/* ... */`。

#### 4.8.7 Modifiers

类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。

```
1 public protected private abstract static final transient volatile synchronized native strictfp 
```

## 命名约定

### 5.1 对所有标识符都通用的规则

标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式`\w+`。

在Google其它编程语言风格中使用的特殊前缀或后缀，如`name_`, `mName`, `s_name`和`kName`，在Java编程风格中都不再使用。

### 5.2 标识符类型的规则

#### 5.2.1 包名

包名全部小写，连续的单词只是简单地连接起来，不使用下划线。

#### 5.2.2 类名

类名都以`UpperCamelCase`风格编写。

类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。

测试类的命名以它要测试的类的名称开始，以`Test`结束。例如，`HashTest`或`HashIntegrationTest`。

#### 5.2.3 方法名

方法名都以`lowerCamelCase`风格编写。

方法名通常是动词或动词短语。

下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：`test<MethodUnderTest>_<state>`，例如`testPop_emptyStack`。 并不存在唯一正确的方式来命名测试方法。

#### 5.2.4 常量名

常量名命名模式为`CONSTANT_CASE`，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？

每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远不`打算`改变对象一般是不够的，它要真的一直不变才能将它示为常量。

```
1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Constants static final int NUMBER = 5; static final ImmutableList<String> NAMES = ImmutableList.of("Ed", "Ann"); static final Joiner COMMA_JOINER = Joiner.on(',');  // because Joiner is immutable static final SomeMutableType[] EMPTY_ARRAY = {}; enum SomeEnum { ENUM_CONSTANT } // Not constants static String nonFinal = "non-final"; final String nonStatic = "non-static"; static final Set<String> mutableCollection = new HashSet<String>(); static final ImmutableSet<SomeMutableType> mutableElements = ImmutableSet.of(mutable); static final Logger logger = Logger.getLogger(MyClass.getName()); static final String[] nonEmptyArray = {"these", "can", "change"}; 
```

这些名字通常是名词或名词短语。

#### 5.2.5 非常量字段名

非常量字段名以`lowerCamelCase`风格编写。

这些名字通常是名词或名词短语。

#### 5.2.6 参数名

参数名以`lowerCamelCase`风格编写。

参数应该避免用单个字符命名。

#### 5.2.7 局部变量名

局部变量名以`lowerCamelCase`风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。

虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。

即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。

#### 5.2.8 类型变量名

类型变量可用以下两种风格之一进行命名：

- 单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。
- 以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。

### 5.3 驼峰式命名法(CamelCase)

[驼峰式命名法](http://zh.wikipedia.org/wiki/駝峰式大小寫)分大驼峰式命名法(`UpperCamelCase`)和小驼峰式命名法(`lowerCamelCase`)。 有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如”IPv6”或”iOS”)。Google指定了以下的转换方案。

名字从`散文形式`(prose form)开始:

1. 把短语转换为纯ASCII码，并且移除任何单引号。例如：”Müller’s algorithm”将变成”Muellers algorithm”。
2. 把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。
   - 推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如”AdWords”将分割成”ad words”)。 需要注意的是”iOS”并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。
3. 现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：
   - 每个单词的第一个字母都大写，来得到大驼峰式命名。
   - 除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。
4. 最后将所有的单词连接起来得到一个标识符。

示例：

```
1 2 3 4 5 6 7 8 Prose form                Correct               Incorrect ------------------------------------------------------------------ "XML HTTP request"        XmlHttpRequest        XMLHTTPRequest "new customer ID"         newCustomerId         newCustomerID "inner stopwatch"         innerStopwatch        innerStopWatch "supports IPv6 on iOS?"   supportsIpv6OnIos     supportsIPv6OnIOS "YouTube importer"        YouTubeImporter                          YoutubeImporter* 
```

加星号处表示可以，但不推荐。

> Note：在英语中，某些带有连字符的单词形式不唯一。例如：”nonempty”和”non-empty”都是正确的，因此方法名`checkNonempty`和`checkNonEmpty`也都是正确的。

## 编程实践

### 6.1 @Override：能用则用

只要是合法的，就把`@Override`注解给用上。

### 6.2 捕获的异常：不能忽视

除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个`AssertionError`重新抛出。)

如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。

```
1 2 3 4 5 6 7 try {  int i = Integer.parseInt(response);  return handleNumericResponse(i); } catch (NumberFormatException ok) {  // it's not numeric; that's fine, just continue } return handleTextResponse(response); 
```

**例外**：在测试中，如果一个捕获的异常被命名为`expected`，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。

```
1 2 3 4 5 try {  emptyStack.pop();  fail(); } catch (NoSuchElementException expected) { } 
```

### 6.3 静态成员：使用类进行调用

使用类名调用静态的类成员，而不是具体某个对象或表达式。

```
1 2 3 4 Foo aFoo = ...; Foo.aStaticMethod(); // good aFoo.aStaticMethod(); // bad somethingThatYieldsAFoo().aStaticMethod(); // very bad 
```

### 6.4 Finalizers: 禁用

极少会去重写`Object.finalize`。

> Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解 [Effective Java](http://books.google.com/books?isbn=8131726592) 第7条款：“Avoid Finalizers”，然后不要使用它。

## Javadoc

### 7.1 格式

#### 7.1.1 一般形式

Javadoc块的基本格式如下所示：

```
1 2 3 4 5 /** * Multiple lines of Javadoc text are written here, * wrapped normally... */ public int method(String p1) { ... } 
```

或者是以下单行形式：

```
1 /** An especially short bit of Javadoc. */ 
```

基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。

#### 7.1.2 段落

空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签`<p>`，并且它和第一个单词间没有空格。

#### 7.1.3 Javadoc标记

标准的Javadoc标记按以下顺序出现：`@param`, `@return`, `@throws`, `@deprecated`, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。

### 7.2 摘要片段

每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。

这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以`A {@code Foo} is a...`或`This method returns...`开头, 它也不会是一个完整的祈使句，如`Save the record...`。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。

> Tip：一个常见的错误是把简单的Javadoc写成`/** @return the customer ID */`，这是不正确的。它应该写成`/** Returns the customer ID. */`。

### 7.3 哪里需要使用Javadoc

至少在每个public类及它的每个public和protected成员处使用Javadoc，以下是一些例外：

#### 7.3.1 例外：不言自明的方法

对于简单明显的方法如`getFoo`，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。

单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。

> Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名`getCanonicalName`， 就不应该忽视文档说明，因为读者很可能不知道词语`canonical name`指的是什么。

#### 7.3.2 例外：重写

如果一个方法重写了超类中的方法，那么Javadoc并非必需的。

#### 7.3.3 可选的Javadoc

对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成Javadoc，这样更统一更友好。

## 后记
## 壹，自由遐想

1，Android有四大组件，如何才能实现，强有力的功能出来，

2，如何认知服务呢，从命名的角度来说，提供服务，

3，其次，在任务上面，除了服务，可以开启多线程啊，不能使用，是因为生命周期的原因吗，

4，活动的目的，是在于和用户进行交互，关键是如何明确相互之间的分工和合作，如何协作完成整体项目的构造和完成，也在一定的意义上面，是为了研究，如何使用好这些组件，其使用在于，我们想要什么样的组件，使用的结果是什么样的，我们要去使用什么，达到什么样的效果，就算没有这项技术，我们也能描述相关的动作，android的功效就是在可视化的基础上，进行数据的流动和交互，在整个可视化的基础上，形象化的说，每一次操作，都是在促动数据的流动，Activity是用来管理所有可视化的组件的，并接受用户的操作，

5,这一切的过程，就如同阅读一个玩具机器人的使用指南一样，我们要把握所有的操作之后，才能很好的操作这个机器人，

## 贰，研究外面的文档

外面的文档，会介绍，使用这个，是调用什么函数，

## 叁，我想要的是什么

最大的目标是，能够重新构造一个这样子的模型出来。

其次，我想要明确知道它的工作的流程，在这个流程里面，有哪些成员参与了，是如何协作的，我觉得这个更加适合我自己，我只需要知道它的工作流程就行了。

再次，在人为的操作过程中，方法是如何自己调用的，这个也属于其工作流程。

## 肆，工作流程（Just tell me ,How does it work）

### 四大组件之服务   工作流程

1，从常理上来说，使用服务之前，我们需要定义一个服务，从外部来说，需要在manifest中注册<Service >，自己extends Service，从内部来说，依据其生命周期的父函数，其生命周期，可以理解为函数之间的数学关系，即是方法之间的函数映射关系，通过写startService来间接的调用oncreate和onStartCommand,如果调用了stopService，那么就是调用onDestroy,  

随着绑定的操作的执行，其执行的，是MVVM的思想，绑定一次，阅读一次，传递一次数据；利用Ibinder的子类Binder，继承下来，解绑绑定来完成，如此循环来传递数据。

其基本思想，都是围绕返回值IBinder来组织的数据。



### 四大组件之广播   工作流程

1，额外的谈一谈，广播的意义，举个栗子，如果电话进来了，那么，如何通知我现在正在运行的音乐播放服务呢，那就是通过广播，停止音乐播放，否则，就会影响到

2，对于广播，我该如何告诉我这个是个广播呢，通过继承BroadCast来完成定义，关于注册，可以在manifest中<receiver>标签来实现，静态注册，可以用来监听启动这类的广播。

3，相对起来，广播比服务更加简单，只需要定义和添加action就可以了。而向外部提供的话，唯一的标识也是action。函数模型很简单。



### 四大组件之内容提供者  工作流程

1，内容提供者需要在manifest中绑定访问的uri和响应这个uri的ContentProvider，便于外部其他应用通过uri映射到对应的ContentProvider，并能定义外部进程能对我自己的数据做些什么，

ps：刚开始，觉得很复杂，因为只是看到别人的事例，在此处，应该是去看原型函数，

### SQL工作流程

1，SQL解决的问题，是一个存储的问题，

### 关于数据持久化的论题

1，持久化的数据，不受手机是否有电，都能够进行保存住的数据，我们可以进行文件保存，可以share来保存，也可以通过数据库来保存，相关的操作，都会在内存空间建立起对应的文件夹，使数据得到持久化。也包括将数据同步到远端的服务器上面，持久化

2，整个App在使用的过程中，会产生一些数据，哪些数据是值得存储的，

## 伍，他人信息记录

1，intent是各大组件之间进行相互启动的一个信息对象载体，

2,操作home键的时候，activity已经被销毁了。

3，内部类是可以访问外部类的变量的。

4,所有的机制，本质上就是用于完成，什么时候调用函数的情况，其次，我通过这个函数去完成什么任务。

5，android的生命活动体征有哪些

6，能写出来，说明已经理清楚了。

7，学习一个新的语法的东西，并不仅仅只是学习怎么使用，其实，我也要学习，如何设计的思维，这样子，使用的时候，会更加得心应手，也可以学到很多东西，触类旁通。也可以通过这个了解到相关的软件设计的业务逻辑。对于SQL这种类型的语言，想想，可以怎么样也实现出这样的使用效果来。

8，对于一些单元调试，应该想想，要回答，自己有什么疑问，用什么方式来解决自己的疑问。

9，自己开展后续的构造的基础，是基于前面系统的基础上的。

10，至少要知道有什么组件，组件内部有什么函数，函数的功能是什么，如何协调起来，然后描述其整体功能，然后了解其背后的系统原理，完成这个系统，需要哪些组件，组件之间如何穿插，负责了什么功能，具体由什么来负责的。

11，把系统自带的View归为自己自定义的View来看待。

12，看视频和看文档，看代码，在一定的程度上，是一致的。

13，第一步，确定需要做的题目，第二步，依据题目组织文章，第三步，看看是否有必要进行测试，第四步，上传

## 陆，Android药方

在Android开发里面，肯定会出现各种各样的疑难杂症，仿造古人写药方的方式，还有制造严密的机器的方式，制造一份对应的文档系统。

#### 1、什么是 ANR 如何避免它？

答：应用程序在一段时间内没有响应，系统会弹出一个对话框，这个对话框叫做应用程序无响应（ANR：Application NotResponding）对话框。 用户可以选择让程序继续运行，但是，这样的对话框很影响用户的使用体验。因此 ，在程序里对响应性能的设计很重要这样，这样系统就不会显 示 ANR 给用户。

不同的组件发生 ANR 的时间不一样，Activity 是 5 秒，BroadCastReceiver 是 10 秒，Service 是 20 秒（均为前台）。

- 主线程被 IO 操作（从 4.0 之后网络 IO 不允许在主线程中）阻塞。
- 主线程中存在耗时的计算
- 主线程中错误的操作，比如 Thread.wait 或者 Thread.sleep 等 Android 系统会监控程序的响应状况，一旦出现下面两种情况，则弹出 ANR 对话框
- 应用在 5 秒内未响应用户的输入事件（如按键或者触摸）
- BroadcastReceiver 未在 10 秒内完成相关的处理
- Service 在特定的时间内无法处理完成 20 秒

修正：



1、使用 AsyncTask 处理耗时 IO 操作。

2、使用 Thread 或者 HandlerThread 时，调用 Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND) 设置优先级，否则仍然会降低程序响应，因为默认 Thread 的优先级和主线程相同。

3、使用 Handler 处理工作线程结果，而不是使用 Thread.wait() 或者 Thread.sleep() 来阻塞主线程。



4、Activity 的 onCreate 和 onResume 回调中尽量避免耗时的代码。 BroadcastReceiver 中 onReceive 代码也要尽量减少耗时，建议使用 IntentService 处理。



##### 解决方案：

将所有耗时操作，比如访问网络，Socket 通信，查询大 量 SQL 语句，复杂逻辑计算等都放在子线程中去，然 后通过 handler.sendMessage、runonUIThread、AsyncTask、RxJava 等方式更新 UI。无论如何都要确保用户界面的流畅 度。如果耗时操作需要让用户等待，那么可以在界面上显示度条。



## 柒，Android构造秘籍



## 捌，计算机活的世界

#### 1、横竖屏切换时候 Activity 的生命周期

不设置 Activity 的 android:configChanges 时，切屏会重新回调各个生命周期，切横屏时会执行一次，切竖屏时会执行两次。 设置 Activity 的 android:configChanges=”orientation” 时，切屏还是会调用各个生命周期，切换横竖屏只会执行一次 设置 Activity 的 android:configChanges=”orientation |keyboardHidden” 时，切屏不会重新调用各个生命周期，只会执行 onConfigurationChanged 方法

同步：一定要等任务执行完了，得到结果，才执行下一个任务。

异步：不等任务执行完，直接执行下一个任务。 

**并行和串行指的是任务的执行方式。串行是指多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个。并行指的是多个任务可以同时执行，异步是多个任务并行的前提条件。**

并发指的是任务数多余cpu核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）

同步、异步：

​     指的是能否开启新的线程。同步不能开启新的线程，异步可以。

***\*并行”\****指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同CPU上**同时**执行。（hadoop集群就是并行计算的）

当应用遇到意外情况（如：内存不足、用户直接按 Home 键）由系统销毁一个 Activity 时，onSaveInstanceState() 会被调用。但是当用户主动去销毁一个 Activity 时，例如在应用中按返回键，onSaveInstanceState() 就不会被调用。因为在这种情况下，用户的行为决定了不需要保存 Activity 的状态。通常 onSaveInstanceState() 只适合用于保存一些临时性的状态，而 onPause() 适合用于数据的持久化保存。在 activity 被杀掉之前调用保存每个实例的状态, 以保证该状态可以在 onCreate(Bundle) 或者 onRestoreInstanceState(Bundle) (传入的 Bundle 参数是由 onSaveInstanceState 封装好的) 中恢复。这个方法在一个 activity 被杀死前调用，当该 activity 在将来某个时刻回来时可以恢复其先前状态。 例如，如果 activity B 启用后位于 activity A 的前端，在某个时刻 activity A 因为系统回收资源的问题要被杀掉，A 通过 onSaveInstanceState 将有机会保存其用户界面状态，使得将来用户返回到 activity A 时能通过 onCreate(Bundle) 或者 onRestoreInstanceState(Bundle) 恢复界面的状态



getApplication() 用来获取 Application 实例的，但是这个方法只有在 Activity 和 Service 中才能调用的到。那也许在绝大多数情况下我们都是在 Activity 或者 Servic 中使用 Application 的，但是如果在一些其它的场景，比如 BroadcastReceiver 中也想获得 Application 的实例，这时就可以借助 getApplicationContext() 方法，getApplicationContext() 比 getApplication() 方法的作用域会更广一些，任何一个 Context 的实例，只要调用 getApplicationContext() 方法都可以拿到我们的 Application 对象。



进行跨进程通信，实现进程间的数据交互和共享。通过 Context 中 getContentResolver() 获得实例，通过 Uri 匹配进行数据的增删改查。ContentProvider 使用表的形式来组织数据，无论数据的来源是什么，ConentProvider 都会认为是一种表，然后把数据组织成表格。

Thread 线程，独立运行与于 Activity 的，当 Activity 被 finish 后，如果没有主动停止 Thread 或者 run 方法没有执行完，其会一直执行下去。

Android 怎么加速启动 Activity？

- onCreate() 中不执行耗时操作 把页面显示的 View 细分一下，放在 AsyncTask 里逐步显示，用 Handler 更好。这样用户的看到的就是有层次有步骤的一个个的 View 的展示，不会是先看到一个黑屏，然后一下显示所有 View。最好做成动画，效果更自然。利用多线程的目的就是尽可能的减少 onCreate() 和 onReume() 的时间，使得用户能尽快看到页面，操作页面。减少主线程阻塞时间。优化布局文件。

整个消息的循环流程还是比较清晰的，具体说来：

- 1、Handler 通过 sendMessage() 发送消息 Message 到消息队列 MessageQueue。
- 2、Looper 通过 loop() 不断提取触发条件的 Message，并将 Message 交给对应的 target handler 来处理。
- 3、target handler 调用自身的 handleMessage() 方法来处理 Message。



内存泄漏（Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存

Handler 允许我们发送延时消息，如果在延时期间用户关闭了 Activity，那么该 Activity 会泄露。 这个泄露是因为 Message 会持有 Handler，而又因为 Java 的特性，内部类会持有外部类，使得 Activity 会被 Handler 持有，这样最终就导致 Activity 泄露。

解决：将 Handler 定义成静态的内部类，在内部持有 Activity 的弱引用，并在 Acitivity 的 onDestroy() 中调用 handler.removeCallbacksAndMessages(null) 及时移除所有消息。

在 ActivityThread.main() 方法中调用了 Looper.prepareMainLooper() 方法创建了 主线程的 Looper , 并且调用了 loop() 方法，所以我们就可以直接使用 Handler 了。



主线程的 Looper 不允许退出
主线程不允许退出，退出就意味 APP 要挂。



Handler 里藏着的 Callback 能干什么？
Handler.Callback 有优先处理消息的权利 ，当一条消息被 Callback 处理并拦截（返回 true），那么 Handler 的 handleMessage(msg) 方法就不会被调用了；如果 Callback 处理了消息，但是并没有拦截，那么就意味着一个消息可以同时被 Callback 以及 Handler 处理。

主线程的死循环一直运行是不是特别消耗 CPU 资源呢？
并不是，这里就涉及到 Linux pipe/epoll 机制，简单说就是在主线程的 MessageQueue 没有消息时，便阻塞在 loop 的 queue.next() 中的 nativePollOnce() 方法里，此时主线程会释放 CPU 资源进入休眠状态，直到下个消息到达或者有事务发生，通过往 pipe 管道写端写入数据来唤醒主线程工作。这里采用的 epoll 机制，是一种 IO 多路复用机制，可以同时监控多个描述符，当某个描述符就绪 (读或写就绪)，则立刻通知相应程序进行读或写操作，本质是同步 I/O，即读写是阻塞的。所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量 CPU 资源。

分页加载就是一页一页加载数据，当滑动到底部、没有更多数据加载的时候，我们可以手动调用接口，重新刷新 RecyclerView。

26、通过 google 提供的 Gson 解析 json 时，定义 JavaBean 的规则是什么？实现序列化 Serializable，属性名必须与 json 串中属性名保持一致 （因为 Gson 解析 json 串底层用到了 Java 的反射原理）

google 提供的 Gson 通过 fromJson() 实现对象的反序列化（即将 json 串转换为对象类型） 通过 toJson() 实现对象的序列化 （即将对象类型转换为 json 串）

FixThreadPool

只有核心线程, 并且数量固定的, 也不会被回收, 所有线程都活动时, 因为队列没有限制大小, 新任务会等待执行.优点: 更快的响应外界请求.

SingleThreadPool

只有一个核心线程, 确保所有的任务都在同一线程中按序完成. 因此不需要处理线程同步的问题.

3).CachedThreadPool

只有非核心线程, 最大线程数非常大, 所有线程都活动时会为新任务创建新线程, 否则会利用空闲线程 (60s 空闲时间, 过了就会被回收, 所以线程池中有 0 个线程的可能) 处理任务.

优点: 任何任务都会被立即执行 (任务队列 SynchronousQuue 相当于一个空集合); 比较适合执行大量的耗时较少的任务.

ScheduledThreadPool

核心线程数固定, 非核心线程（闲着没活干会被立即回收数）没有限制

\1. 资源对象没关闭造成的内存泄漏

描述： 资源性对象比如 (Cursor，File 文件等) 往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于 java 虚拟机内，还存在于 java 虚拟机外。如果我们仅仅是把它的引用设置为 null, 而不关闭它们，往往会造成内存泄漏。因为有些资源性对象，比如 SQLiteCursor(在析构函数 finalize(), 如果我们没有关闭它，它自己会调 close()关闭)，如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。因此对于资源性对象在不使用的时候，应该调用它的 close()函数，将其关闭掉，然后才置为 null. 在我们的程序退出时一定要确保我们的资源性对象已经关闭。

程序中经常会进行查询数据库的操作，但是经常会有使用完毕 Cursor 后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。

构造 Adapter 时，没有使用缓存的 convertView

描述： 以构造 ListView 的 BaseAdapter 为例，在 BaseAdapter 中提供了方法： public View getView(int position, ViewconvertView, ViewGroup parent) 来向 ListView 提供每一个 item 所需要的 view 对象。初始时 ListView 会从 BaseAdapter 中根据当前的屏幕布局实例化一定数量的 view 对象，同时 ListView 会将这些 view 对象缓存起来。当向上滚动 ListView 时，原先位于最上面的 list item 的 view 对象会被回收，然后被用来构造新出现的最下面的 list item。这个构造过程就是由 getView()方法完成的，getView()的第二个形参 View convertView 就是被缓存起来的 list item 的 view 对象 (初始化时缓存中没有 view 对象则 convertView 是 null)。由此可以看出，如果我们不去使用 convertView，而是每次都在 getView() 中重新实例化一个 View 对象的话，即浪费资源也浪费时间，也会使得内存占用越来越大。

Bitmap 对象不在使用时调用 recycle() 释放内存

描述： 有时我们会手工的操作 Bitmap 对象，如果一个 Bitmap 对象比较占内存，当它不在被使用的时候，可以调用 Bitmap.recycle() 方法回收此对象的像素所占用的内存，但这不是必须的，视情况而定。

\4. 试着使用关于 application 的 context 来替代和 activity 相关的 context

这是一个很隐晦的内存泄漏的情况。有一种简单的方法来避免 context 相关的内存泄漏。最显著地一个是避免 context 逃出他自己的范围之外。使用 Application context。这个 context 的生存周期和你的应用的生存周期一样长，而不是取决于 activity 的生存周期。如果你想保持一个长期生存的对象，并且这个对象需要一个 context, 记得使用 application 对象。你可以通过调用 Context.getApplicationContext() or Activity.getApplication() 来获得。

\5. 注册没取消造成的内存泄漏

一些 Android 程序可能引用我们的 Anroid 程序的对象 (比如注册机制)。即使我们的 Android 程序已经结束了，但是别的引用程序仍然还有对我们的 Android 程序的某个对象的引用，泄漏的内存依然不能被垃圾回收。调用 registerReceiver 后未调用 unregisterReceiver。  比如: 假设我们希望在锁屏界面(LockScreen) 中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在 LockScreen 中定义一个 PhoneStateListener 的对象，同时将它注册到 TelephonyManager 服务中。对于 LockScreen 对象，当需要显示锁屏界面的时候就会创建一个 LockScreen 对象，而当锁屏界面消失的时候 LockScreen 对象就会被释放掉。 但是如果在释放 LockScreen 对象的时候忘记取消我们之前注册的 PhoneStateListener 对象，则会导致 LockScreen 无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的 LockScreen 对象没有办法被回收而引起 OutOfMemory, 使得 system_process 进程挂掉。 虽然有些系统程序，它本身好像是可以自动取消注册的(当然不及时)，但是我们还是应该在我们的程序中明确的取消注册，程序结束时应该把所有的注册都取消掉。

\6. 集合中对象没清理造成的内存泄漏

我们通常把一些对象的引用加入到了集合中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是 static 的话，那情况就更严重了。

使用 AndroidProfiler 的 MEMORY 工具：

运行程序，对每一个页面进行内存分析检查。首先，反复打开关闭页面 5 次，然后收到 GC（点击 Profile MEMORY 左上角的垃圾桶图标），如果此时 total 内存还没有恢复到之前的数值，则可能发生了内存泄露。此时，再点击 Profile MEMORY 左上角的垃圾桶图标旁的 heap dump 按钮查看当前的内存堆栈情况，选择按包名查找，找到当前测试的 Activity，如果引用了多个实例，则表明发生了内存泄露。

1、运行程序，所有功能跑一遍，确保没有改出问题，完全退出程序，手动触发 GC，然后使用 adb shell dumpsys meminfo packagename -d 命令查看退出界面后 Objects 下的 Views 和 Activities 数目是否为 0，如果不是则通过 Leakcanary 检查可能存在内存泄露的地方，最后通过 MAT 分析，如此反复，改善满意为止。

您可以使用对System.gc（）的调用来请求JVM触发GC。 API文档说，这“表明Java虚拟机将精力花在回收未使用的对象上”。如果使用的是Oracle的HotSpot JVM，则每次调用它都会运行完整的GC。

但是，这不太可能（如评论中所述）解决您的问题。 GC非常擅长回收不再需要的空间，因此，您的堆只有1Gb内存，这很可能导致您出现OOM异常。您的图片有多大？您要同时处理多少张？您应该能够进行一些简单的数学运算，以计算出所需的最小堆大小。

类的初始化顺序依次是？

（静态变量、静态代码块）>（变量、代码块）> 构造方法

可以肯定的是，两者都是支持序列化和反序列化的操作。

两者最大的区别在于 存储媒介的不同，Serializable 使用 I/O 读写存储在硬盘上，而 Parcelable 是直接 在内存中读写。很明显，内存的读写速度通常大于 IO 读写，所以在 Android 中传递数据优先选择 Parcelable。

Serializable 会使用反射，序列化和反序列化过程需要大量 I/O 操作， Parcelable 自已实现封送和解封（marshalled &unmarshalled）操作不需要用反射，数据也存放在 Native 内存中，效率要快很多

使用 Parcelable 插件（Android Parcelable code generator）进行实体类的序列化的实现。

只有在一种情况下，这样做是可行的：



在 try 语句中声明了很大的对象，导致 OOM，并且可以确认 OOM 是由 try 语句中的对象声明导致的，那么在 catch 语句中，可以释放掉这些对象，解决 OOM 的问题，继续执行剩余语句。

但是这通常不是合适的做法。

Java 中管理内存除了显式地 catch OOM 之外还有更多有效的方法：比如 SoftReference, WeakReference, 硬盘缓存等。 在 JVM 用光内存之前，会多次触发 GC，这些 GC 会降低程序运行的效率。 如果 OOM 的原因不是 try 语句中的对象（比如内存泄漏），那么在 catch 语句中会继续抛出 OOM。

私有进程和公有进程的区别：
android:process=":remote"，以冒号开头，冒号后面的字符串原则上是可以随意指定的。如果我们的包名为“com.biyou.multiprocess”，则实际的进程名
为“com.biyou.multiprocess:remote”。这种设置形式表示该进程为当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中。
全局进程
进程名称不以“:”开头的进程都可以叫全局进程，如android:process="com.secondProcess"，以小写字母开头，表示运行在一个以这个名字命名的全局进程中，其他应用通过设置相同的ShareUID可以和它跑在同一个进程。

我们知道Android系统对每个应用进程的内存占用是有限制的，而且占用内存越大的进程，通常被系统杀死的可能性越大。让一个组件运行在单独的进程中，可以减少主进程所占用的内存，避免OOM问题，降低被系统杀死的概率，

比如我做的应用大而全，里面肯定会有很多模块，假如有地图模块、大图浏览、自定义WebView等等（这些都是吃内存大户），还会有一些诸如下载服务，监控服务等等，一个成熟的应用一定是多模块化的。

 多进程情况下会出现两个进程在同一时刻访问同一个数据库文件的情况。这就可能造成资源的竞争访问，导致诸如数据库损坏、数据丢失等。在多线程的情况下我们有锁机制控制资源的共享，但是在多进程中比较难，虽然有文件锁、排队等机制，但是在Android里很难实现。解决办法就是多进程的时候不并发访问同一个文件，比如子进程涉及到操作数据库，就可以考虑调用主进程进行数据库的操作。

在前台的时候，和 **AB** 是一样的，adj 都是 0，当切到后台，或者 back 结束时，**C** 对应的 adj 就是 **2**，也就是可感知进程。**adj=2** 可以说是很高优先级了，非 root 手机，非系统应用已经没有办法将其杀掉了。具体可参见 **ActivityManagerService**：中的 **killBackgroundProcesses** 方法以及 **killPackageProcessesLocked** 方法。**adj<5** 的应用不会被杀掉。

多进程还有一种非常有用的场景，就是多模块应用。比如我做的应用大而全，里面肯定会有很多模块，假如有地图模块、大图浏览、自定义 WebView 等等（这些都是吃内存大户），还会有一些诸如下载服务，监控服务等等，一个成熟的应用一定是多模块化的。

save：用来保存 Canvas 的状态。save 之后，可以调用 Canvas 的平移、放缩、旋转、错切、裁剪等操作。

restore：用来恢复 Canvas 之前保存的状态。防止 save 后对 Canvas 执行的操作对后续的绘制有影响。

save 和 restore 要配对使用（restore 可以比 save 少，但不能多），如果 restore 调用次数比 save 多，会引发 Error。save 和 restore 操作执行的时机不同，就能造成绘制的图形不同。

1. 从文件系统中加载图片也没有内存中加载那么快，甚至可能内存中加载也不够快。因此在ListView中应设立busy标志位，当ListView滚动时busy设为true，停止各个view的图片加载。否则可能会让UI不够流畅用户体验度降低。
2. 文件加载图片放在子线程实现，否则快速滑动屏幕会卡
3. 开启网络访问等耗时操作需要开启新线程，应使用线程池避免资源浪费，最起码也要用AsyncTask。
4. Bitmap从网络下载下来最好先放到文件系统中缓存。这样一是方便下一次加载根据本地uri直接找到，二是如果Bitmap过大，从本地缓存可以方便的使用Option.inSampleSize配合Bitmap.decodeFile(ui, options)或Bitmap.createScaledBitmap来进行内存压缩

**电脑性能**（Computer Performance）一般会以[电脑](https://zh.wikipedia.org/wiki/電腦)系统在指定时间和使用资源的条件下，所完成工作的数量来表示。



### AOP原理

如何把切面织入到核心逻辑中？这正是AOP需要解决的问题。换句话说，如果客户端获得了`BookService`的引用，当调用`bookService.createBook()`时，如何对调用方法进行拦截，并在拦截前后进行安全检查、日志、事务等处理，就相当于完成了所有业务功能。

在Java平台上，对于AOP的织入，有3种方式：

1. 编译期：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并扩展编译器，AspectJ就扩展了Java编译器，使用关键字aspect来实现织入；
2. 类加载器：在目标类被装载到JVM时，通过一个特殊的类加载器，对目标类的字节码重新“增强”；
3. 运行期：目标对象和切面都是普通Java类，通过JVM的动态代理功能或者第三方库实现运行期动态织入。

AOP技术看上去比较神秘，但实际上，它本质就是一个动态代理，让我们把一些常用功能如权限检查、日志、事务等，从每个业务方法中剥离出来。

PS：只在编译的时候，把额外的非核心代码加入到编译文件之中，对于代码的可维护性，可读性，都有很好的拓展作用，

对于同样的代码，可以通过父类定义，子类调用的方式来封装抽象，也可以通过平行抽出来，作为一个公共的类来管理，

- ![avatar](https://img-blog.csdn.net/20170212104704243?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

 OOP 确实也遵循自身的宗旨即将数据及对数据的操作行为放在一起，作为一个相互依存、不可分割的整体，这个整体美其名曰：对象，利用该定义对于相同类型的对象进行分类、抽象后，得出共同的特征，从而形成了类，在 java 程序设计中这些类就是 class，由于类(对象) 基本都是现实世界存在的事物概念（如前面的不同的小房间）因此更接近人们对客观事物的认识，同时把数据和方法 (算法) 封装在一个类 (对象) 中，这样更有利于数据的安全，一般情况下属性和算法只单独属于某个类，从而使程序设计更简单，也更易于维护。

![avaster](https://img-blog.csdn.net/20170215092953013?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YXplamlhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

从图可以看出，每个关注点与核心业务模块分离，作为单独的功能，横切几个核心业务模块，这样的做的好处是显而易见的，每份功能代码不再单独入侵到核心业务类的代码中，即核心模块只需关注自己相关的业务，当需要外围业务 (日志，权限，性能监测、事务控制) 时，这些外围业务会通过一种特殊的技术自动应用到核心模块中，这些关注点有个特殊的名称，叫做“横切关注点”，上图也很好的表现出这个概念，另外这种抽象级别的技术也叫 AOP（面向切面编程），正如上图所展示的横切核心模块的整面，因此 AOP 的概念就出现了，而所谓的特殊技术也就面向切面编程的实现技术，AOP 的实现技术有多种，其中与 Java 无缝对接的是一种称为 AspectJ 的技术。

这里还需要注意的是，AOP 的出现确实解决外围业务代码与核心业务代码分离的问题，但它并不会替代 OOP，如果说 OOP 的出现是把编码问题进行模块化，那么 AOP 就是把涉及到众多模块的某一类问题进行统一管理，因此在实际开发中 AOP 和 OOP 同时存在并不奇怪，

基于这套理论思想，在实际的软件开发中，整个软件系统事实也是由系列相互依赖的对象所组成，而这些对象也是被抽象出来的类。相信大家在实际开发中是有所体验的(本篇文件假定读者已具备面向对象的开发思想包括封装、继承、多态的知识点)。但随着软件规模的增大，应用的逐渐升级，慢慢地，OOP 也开始暴露出一些问题，现在不需要急于知道它们，通过案例，我们慢慢感受：

在 Android 中，Bitmap 的存储分为两部分，一部分是 Bitmap 的数据，一部分是 Bitmap 的引用。 在 Android2.3 时代，Bitmap 的引用是放在堆中的，而 Bitmap 的数据部分是放在栈中的，需要用户调用 recycle 方法手动进行内存回收，而在 Android2.3 之后，整个 Bitmap，包括数据和引用，都放在了堆中，这样，整个 Bitmap 的回收就全部交给 GC 了，这个 recycle 方法就再也不需要使用了。

不会立即释放对象占用的内存。 如果对象的引用被置为 null，只是断开了当前线程栈帧中对该对象的引用关系，而 垃圾收集器是运行在后台的线程，只有当用户线程运行到安全点 (safe point) 或者安全区域才会扫描对象引用关系，扫描到对象没有被引用则会标记对象，这时候仍然不会立即释放该对象内存，因为有些对象是可恢复的（在 finalize 方法中恢复引用 ）。只有确定了对象无法恢复引用的时候才会清除对象内存。

## 拾，使用场景

1，告诉其他人如何使用我们的东西，为什么一定要用它。

## 拾壹，制作场景

### 1，MVVM使用流程

使用MVVM，第一步就是要想数据如何传递，MVVM是什么呢，是用来实现View和数据源的分离的，从底层，到顶层的一个设计的思路。

一般，这样的操作，从数据源开始设计，先设计一个接口，然后继承接口，再将继承的接口实例化，到这一步后，model就完成了，同样的，也可以为数据库设计一个接口，所有的这些组成了仓库，所有的逻辑处理都在这里完成，但是又有不同的仓库，通过ViewModel制定绑定关系，通过工厂模式，对这些关系进行管理，View层直接对接工厂模式，进行批量的对象的产生。

### 2，小牧餐厅使用流程

使用的是MVC架构，采取的是根据系统提供的api，实时的和服务器进行交互，所以，需要根据服务器定制对应的接口，通过返回来的数据，在各个Activity之间进行传递，根据返回来是否成功。另外，通过prefrence单例模式来进行用户信息的共享。

ps：如果我边点餐边查看菜单的详情，会如何，

### 3，QQ阅读器使用流程

相对于小木餐厅，这个案例，在于说明，数据下载后，如何在本地操作，

### 4，计步器app使用流程

这款产品，传感器部分的使用，是从实际开发的产品角度来进行的，分两步走：

1，进行项目的准备，先将相关的工具代码编写出来，封装各种工具类

2，实现计步功能

### 5，小米商城使用流程

1，分模块进行

2，

## 拾贰，代码阅读

### 1，什么叫做任务

比方说，播放一首歌，首先，要有一段程序去找到这首歌，然后加载这首歌，解析这首歌。用户的每一个操作，都是一个任务，都是要进行处理的，并发的处理，是说，让这个任务得到处理，如果要让线程之间进行通信，要么中断，要么共享内存。

打个比方，建立一个模型，为了及时响应老板的需求，对于老板分发的任务，自己交给其他人去做，最后把结果给自己就行了，那么，自己随时都可以响应老板的要求，积极响应的敏捷，然后是任务的分发。

任务，实质上，是指为了达到一个特定的目标，所要去做的事，就叫做任务。作为一个协调者，要知道达到什么目的，基于目的制定各项任务，再将任务进行分发，最后合成，达成目标。

在这个机器的世界里面，我们利用机器来计算数量，拍摄照片，与远方的朋友取得联系，制作歌曲并播放，编写文件，并存储在远方的服务器上面，并可以与其他人进行共享。要达到这样的目的，机器就要合理的工作起来。

我们不需要具体了解其细节，但是可以知道的是，一个cpu可以完成一定目的，它可以接受一套指令后，按照指令进行工作，但是，如果我们同一时间，需要利用机器达到多个目的，达到同时进行的效果，多个cpu的话，给以给每个cpu分发一个目的指令，但是只有一个的话，那就分时共用，

同样的，如果一个大型的任务，为了达到快速的完成，可以将这个任务进行分割，其实软件设计师就是这个分割者，分配好之后，交给机器去完成，软件设计师其实就是机器的领导者，在理论上面告诉他怎么做，然后真正执行的是这个机器。按照我们的意思去做事情，所以，认知一个软体的前提，不是其具体的技术细节，而是首先，他要完成什么样的一个目的，然后，我们学习，是如何对这个目的需要做的事情进行划分的。同样的，对于阅读别人的代码，也是想想，是实现什么目的的，怎么实现的。

在电商里面，服务器端，对于新加入的用户，也是有必要分配一个线程，用来处理服务器数据的，多个用户，就实行并发处理。

另外，我们可以通过多种语言来实现和cpu等机器的操作目的，



## 拾叁，计划心法

今天把自己之前学的Android的实战案例和MVP的实现的案例全部走完即可。

关于如何梳理业务逻辑：

1，根据代码，自己先自行梳理，建立一个大概的框架，形成自己的一套理解，并解决相关的不理解的地方

2，通过看视频，对自己的理解进行修正

3，通过修正后，形成一套整洁的文档



## 拾四，重构Android

1，需要一个界面来显示，显示控件，android是基于linux来设计的，在这个基础上，已经有触摸屏的技术，可以绘制界面。

2，将这个显示和绘制进行分离，在整个的开发的过程中，需要开辟线程来处理任务，处理之后的结果需要显示，消息传递机制，进程之间消息的传递，组件之间的消息的传递。目前知道的方式有，共享内存，通知拷贝，

3，需要完成什么任务，在一串字符串中，识别并处理任务标准化处理，数学公式的套用处理，建立一个管理文本的对象，通过这个对象，来完成用户的期望的目标，操作一个网页的对象，让本地的客户端能够便利的操作数据。也可以为了采集用户的操作习惯，将这些采集的对象进行处理，从网页上找到数据，并将数据进行本地化展示，将网上的数据采集下来，放在本地，将自己本地的数据放在远端，和远端建立联系，对手机端的采集的数据进行整理，然后传送到远端。

将用户输入的数据，进行存储，并进行合理化的展示，通过机器进行用户数据的采集，并进行监视；将远端的数据进行本地的展示，建立商品信息的处理，

4，在形式上来说，cs架构，对于移动端和网页端都是基于这样的架构来实现的，将输入的数据，进行计算，转化为另外一个可以度量的指标，告诉，怎么度量，利用计算机来协助训练模型，如何利用计算机的处理任务。编程，不仅意味着给cpu分配任务，也告诉他分配的任务怎么执行，最后给我一个什么样的结果。

5，整体的组织架构，是基于线程来组织的。所有的任务都是在线程之间进行穿插的。

## 拾伍，记忆的宫殿

synchronized 同步锁，

同步：一视同仁，同而步之，就是说这个东西，可以同时运行，但是在运行到这一部分的时候，需要依次进入，那如果

```
class SyncThread implements Runnable {
   private static int count;

   public SyncThread() {
      count = 0;
   }

   public  void run() {
      synchronized(this) {
         for (int i = 0; i < 5; i++) {
            try {
               System.out.println(Thread.currentThread().getName() + ":" + (count++));
               Thread.sleep(100);
            } catch (InterruptedException e) {
               e.printStackTrace();
            }
         }
      }
   }

   public int getCount() {
      return count;
   }
}
```

```

```